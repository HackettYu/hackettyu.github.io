<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>HackettYu&#39;s blog</title>
  
  <subtitle>hackettyu</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hackettyu.com/"/>
  <updated>2018-10-25T10:36:14.681Z</updated>
  <id>https://hackettyu.com/</id>
  
  <author>
    <name>HackettYu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>hexo 配置 dns 分流的问题</title>
    <link href="https://hackettyu.com/181025_2/"/>
    <id>https://hackettyu.com/181025_2/</id>
    <published>2018-10-25T04:00:00.000Z</published>
    <updated>2018-10-25T10:36:14.681Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>hexo 同时部署在 coding page 和 github page 后，在域名服务器设置 dns 分流后发现 coding 一直无法申请 ssl。</p><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><p>网上说的把 dns 设置境外线路和国内线路让 dns 分流让国内访问 coding 国外访问 github 加速网页加载，不过分流要看用户配置的 dns 不是看 ip。<br>这导致 我的 coding ssl 证书 申请不成功 因为域名验证成功的必要条件还是要让证书服务提供方能读取到申请者（即 Coding Pages 服务器）所提供的验证信息<br>所以要先暂停境外的分流再申请 coding 的 ssl。</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>我一直找不到问题的原因是我使用的 dns 是 <code>1.1.1.1</code>，这是国外的 dns，导致我一直使用的是 github page，没有加载到 coding page。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
      <category term="debug" scheme="https://hackettyu.com/categories/debug/"/>
    
    
      <category term="hexo" scheme="https://hackettyu.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>centos 7 防火墙命令 firewall-cmd</title>
    <link href="https://hackettyu.com/181025_1/"/>
    <id>https://hackettyu.com/181025_1/</id>
    <published>2018-10-25T02:00:00.000Z</published>
    <updated>2018-10-25T10:24:26.297Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>centos 7 和 centos 6 有不同的防火墙命令，centos 7 的是 firewall-cmd，如果没安装，安装方法如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install firewalld</span><br></pre></td></tr></table></figure></p><p>开启防火墙<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start firewalld.service</span><br></pre></td></tr></table></figure></p><p>关闭防火墙<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld.service</span><br></pre></td></tr></table></figure></p><p>开机自动启动<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> firewalld.service</span><br></pre></td></tr></table></figure></p><p>关闭开机制动启动<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl <span class="built_in">disable</span> firewalld.service</span><br></pre></td></tr></table></figure></p><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><p>基本的添加端口：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=9001/tcp --permanent</span><br><span class="line">firewall-cmd --zone=public --add-port=9001/udp --permanent</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure></p><p>查看：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --list-all</span><br></pre></td></tr></table></figure></p><h2 id="进阶篇"><a href="#进阶篇" class="headerlink" title="进阶篇"></a>进阶篇</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-service=https //临时</span><br><span class="line">firewall-cmd --zone=public --add-port=8080-8081/tcp //临时</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --permanent --zone=public --add-service=https //永久</span><br><span class="line">firewall-cmd --permanent --zone=public --add-port=8080-8081/tcp //永久</span><br></pre></td></tr></table></figure><p>删除<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --permanent --zone=public --remove-rich-rule=<span class="string">"rule family="</span>ipv4<span class="string">" source address="</span>192.168.1.1<span class="string">"</span></span><br></pre></td></tr></table></figure></p><p>查询<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --query-service ftp</span><br><span class="line">yes</span><br><span class="line">firewall-cmd --query-service ssh</span><br><span class="line">yes</span><br><span class="line">firewall-cmd --query-service samba</span><br><span class="line">no</span><br><span class="line">firewall-cmd --query-service http</span><br><span class="line">no</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
      <category term="note" scheme="https://hackettyu.com/categories/note/"/>
    
    
      <category term="linux" scheme="https://hackettyu.com/tags/linux/"/>
    
      <category term="centos" scheme="https://hackettyu.com/tags/centos/"/>
    
  </entry>
  
  <entry>
    <title>关于 java swap 函数</title>
    <link href="https://hackettyu.com/181018_1/"/>
    <id>https://hackettyu.com/181018_1/</id>
    <published>2018-10-18T02:00:00.000Z</published>
    <updated>2018-10-18T08:29:03.180Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在写算法的时候，书本里使用的 c 语言里的 swap 函数，头一热就在 java 里写了一个。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> temp = a;</span><br><span class="line">      a = b;</span><br><span class="line">      b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>美滋滋运行自己的排序算法，居然原样输出，后来发现 java 里没有引用这个概念，自己写的函数不能真正的交换。</p><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><p>这样写：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> itself, <span class="keyword">int</span> dummy)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> itself;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    a = swap(b, b = a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>还可以这样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyInteger</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> x;                   <span class="comment">// single data member</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">MyInteger</span><span class="params">(<span class="keyword">int</span> xIn)</span> </span>&#123; x = xIn; &#125; <span class="comment">// constructor</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> x; &#125;  <span class="comment">// retrieve value</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertValue</span><span class="params">(<span class="keyword">int</span> xIn)</span> </span>&#123; x = xIn;&#125; <span class="comment">// insert</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Swapping</span> </span>&#123;</span><br><span class="line">   <span class="comment">// swap: pass references to objects</span></span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(MyInteger rWrap, MyInteger sWrap)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// interchange values inside objects</span></span><br><span class="line">      <span class="keyword">int</span> t = rWrap.getValue();</span><br><span class="line">      rWrap.insertValue(sWrap.getValue());</span><br><span class="line">      sWrap.insertValue(t);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> a = <span class="number">23</span>, b = <span class="number">47</span>;</span><br><span class="line">      System.out.println(<span class="string">"Before. a:"</span> + a + <span class="string">", b: "</span> + b);</span><br><span class="line">      MyInteger aWrap = <span class="keyword">new</span> MyInteger(a);</span><br><span class="line">      MyInteger bWrap = <span class="keyword">new</span> MyInteger(b);</span><br><span class="line">      swap(aWrap, bWrap);</span><br><span class="line">      a = aWrap.getValue();</span><br><span class="line">      b = bWrap.getValue();</span><br><span class="line">      System.out.println(<span class="string">"After.  a:"</span> + a + <span class="string">", b: "</span> + b);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>是不是三行代码的方式更简单~~~</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
      <category term="debug" scheme="https://hackettyu.com/categories/debug/"/>
    
    
      <category term="java" scheme="https://hackettyu.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>一段用 html 创建流程图的源码</title>
    <link href="https://hackettyu.com/181016_1/"/>
    <id>https://hackettyu.com/181016_1/</id>
    <published>2018-10-16T02:00:00.000Z</published>
    <updated>2018-10-16T09:06:35.253Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>flowchart.js · Playground<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">          .end-element &#123; background-color : #FFCCFF; &#125;</span></span><br><span class="line"><span class="undefined">        </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://cdnjs.cloudflare.com/ajax/libs/raphael/2.2.0/raphael-min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://cdnjs.cloudflare.com/ajax/libs/jquery/1.11.0/jquery.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://flowchart.js.org/flowchart-latest.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;script src="../release/flowchart.min.js"&gt;&lt;/script&gt; --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">            window.onload = function () &#123;</span></span><br><span class="line"><span class="undefined">                var btn = document.getElementById("run"),</span></span><br><span class="line"><span class="undefined">                    cd = document.getElementById("code"),</span></span><br><span class="line"><span class="undefined">                    chart;</span></span><br><span class="line"><span class="undefined">                (btn.onclick = function () &#123;</span></span><br><span class="line"><span class="undefined">                    var code = cd.value;</span></span><br><span class="line"><span class="undefined">                    if (chart) &#123;</span></span><br><span class="line"><span class="undefined">                      chart.clean();</span></span><br><span class="line"><span class="undefined">                    &#125;</span></span><br><span class="line"><span class="undefined">                    chart = flowchart.parse(code);</span></span><br><span class="line"><span class="undefined">                    chart.drawSVG('canvas', &#123;</span></span><br><span class="line"><span class="undefined">                      // 'x': 30,</span></span><br><span class="line"><span class="undefined">                      // 'y': 50,</span></span><br><span class="line"><span class="undefined">                      'line-width': 3,</span></span><br><span class="line"><span class="undefined">                      'maxWidth': 3,//ensures the flowcharts fits within a certian width</span></span><br><span class="line"><span class="undefined">                      'line-length': 50,</span></span><br><span class="line"><span class="undefined">                      'text-margin': 10,</span></span><br><span class="line"><span class="undefined">                      'font-size': 14,</span></span><br><span class="line"><span class="undefined">                      'font': 'normal',</span></span><br><span class="line"><span class="undefined">                      'font-family': 'Helvetica',</span></span><br><span class="line"><span class="undefined">                      'font-weight': 'normal',</span></span><br><span class="line"><span class="undefined">                      'font-color': 'black',</span></span><br><span class="line"><span class="undefined">                      'line-color': 'black',</span></span><br><span class="line"><span class="undefined">                      'element-color': 'black',</span></span><br><span class="line"><span class="undefined">                      'fill': 'white',</span></span><br><span class="line"><span class="undefined">                      'yes-text': 'yes',</span></span><br><span class="line"><span class="undefined">                      'no-text': 'no',</span></span><br><span class="line"><span class="undefined">                      'arrow-end': 'block',</span></span><br><span class="line"><span class="undefined">                      'scale': 1,</span></span><br><span class="line"><span class="undefined">                      'symbols': &#123;</span></span><br><span class="line"><span class="undefined">                        'start': &#123;</span></span><br><span class="line"><span class="undefined">                          'font-color': 'red',</span></span><br><span class="line"><span class="undefined">                          'element-color': 'green',</span></span><br><span class="line"><span class="undefined">                          'fill': 'yellow'</span></span><br><span class="line"><span class="undefined">                        &#125;,</span></span><br><span class="line"><span class="undefined">                        'end':&#123;</span></span><br><span class="line"><span class="undefined">                          'class': 'end-element'</span></span><br><span class="line"><span class="undefined">                        &#125;</span></span><br><span class="line"><span class="undefined">                      &#125;,</span></span><br><span class="line"><span class="undefined">                      'flowstate' : &#123;</span></span><br><span class="line"><span class="undefined">                        'past' : &#123; 'fill' : '#CCCCCC', 'font-size' : 12&#125;,</span></span><br><span class="line"><span class="undefined">                        'current' : &#123;'fill' : 'yellow', 'font-color' : 'red', 'font-weight' : 'bold'&#125;,</span></span><br><span class="line"><span class="undefined">                        'future' : &#123; 'fill' : '#FFFF99'&#125;,</span></span><br><span class="line"><span class="undefined">                        'request' : &#123; 'fill' : 'blue'&#125;,</span></span><br><span class="line"><span class="undefined">                        'invalid': &#123;'fill' : '#444444'&#125;,</span></span><br><span class="line"><span class="undefined">                        'approved' : &#123; 'fill' : '#58C4A3', 'font-size' : 12, 'yes-text' : 'APPROVED', 'no-text' : 'n/a' &#125;,</span></span><br><span class="line"><span class="undefined">                        'rejected' : &#123; 'fill' : '#C45879', 'font-size' : 12, 'yes-text' : 'n/a', 'no-text' : 'REJECTED' &#125;</span></span><br><span class="line"><span class="undefined">                      &#125;</span></span><br><span class="line"><span class="undefined">                    &#125;);</span></span><br><span class="line"><span class="undefined">                    $('[id^=sub1]').click(function()&#123;</span></span><br><span class="line"><span class="undefined">                      alert('info here');</span></span><br><span class="line"><span class="undefined">                    &#125;);</span></span><br><span class="line"><span class="undefined">                &#125;)();</span></span><br><span class="line"><span class="undefined">            &#125;;</span></span><br><span class="line"><span class="undefined">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">id</span>=<span class="string">"code"</span> <span class="attr">style</span>=<span class="string">"width: 100%;"</span> <span class="attr">rows</span>=<span class="string">"11"</span>&gt;</span></span><br><span class="line">st=&gt;start: Start|past:&gt;http://www.google.com[blank]</span><br><span class="line">e=&gt;end: End:&gt;http://www.google.com</span><br><span class="line">op1=&gt;operation: My Operation|past</span><br><span class="line">op2=&gt;operation: Stuff|current</span><br><span class="line">sub1=&gt;subroutine: My Subroutine|invalid</span><br><span class="line">cond=&gt;condition: Yes</span><br><span class="line">or No?|approved:&gt;http://www.google.com</span><br><span class="line">c2=&gt;condition: Good idea|rejected</span><br><span class="line">io=&gt;inputoutput: catch something...|request</span><br><span class="line"></span><br><span class="line">st-&gt;op1(right)-&gt;cond</span><br><span class="line">cond(yes, right)-&gt;c2</span><br><span class="line">cond(no)-&gt;sub1(left)-&gt;op1</span><br><span class="line">c2(yes)-&gt;io-&gt;e</span><br><span class="line">c2(no)-&gt;op2-&gt;e</span><br><span class="line"></span><br><span class="line">st@&gt;op1(&#123;"stroke":"Red"&#125;)@&gt;cond(&#123;"stroke":"Red","stroke-width":6,"arrow-end":"classic-wide-long"&#125;)@&gt;c2(&#123;"stroke":"Red"&#125;)@&gt;op2(&#123;"stroke":"Red"&#125;)@&gt;e(&#123;"stroke":"Red"&#125;)<span class="tag">&lt;/<span class="name">textarea</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"run"</span> <span class="attr">type</span>=<span class="string">"button"</span>&gt;</span>Run<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"canvas"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
      <category term="digest" scheme="https://hackettyu.com/categories/digest/"/>
    
    
      <category term="html" scheme="https://hackettyu.com/tags/html/"/>
    
  </entry>
  
  <entry>
    <title>Windows 下磁盘多余的图标删除</title>
    <link href="https://hackettyu.com/181010_1/"/>
    <id>https://hackettyu.com/181010_1/</id>
    <published>2018-10-10T02:00:00.000Z</published>
    <updated>2018-10-16T08:48:35.259Z</updated>
    
    <content type="html"><![CDATA[<h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><p>在注册表里打开下面两个路径看除了默认是否还有其它的，网上的方法只有第一条：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\MyComputer\NameSpace</span><br><span class="line">HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\MyComputer\NameSpace</span><br></pre></td></tr></table></figure></p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><ul><li>第一条是系统的。</li><li>第二条是用户的。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
      <category term="log" scheme="https://hackettyu.com/categories/log/"/>
    
    
      <category term="windows" scheme="https://hackettyu.com/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>电脑缺少 windows media player</title>
    <link href="https://hackettyu.com/181008_1/"/>
    <id>https://hackettyu.com/181008_1/</id>
    <published>2018-10-08T02:00:00.000Z</published>
    <updated>2018-10-16T08:46:28.522Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>因为电脑缺少 windows media play 无法安装 windows 版本的 icloud<br>尝试在功能上打开失败，尝试用 dism 打开失败，尝试官网安装包安装</p><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><p>直接在可选功能里安装，因为之前自己卸载了</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
      <category term="debug" scheme="https://hackettyu.com/categories/debug/"/>
    
    
      <category term="windows" scheme="https://hackettyu.com/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>linux ln 命令之硬链接和软连接</title>
    <link href="https://hackettyu.com/181006_1/"/>
    <id>https://hackettyu.com/181006_1/</id>
    <published>2018-10-06T02:00:00.000Z</published>
    <updated>2018-10-16T08:44:16.250Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>本来像利用 link 一个 cheat 文件在 <code>/user</code> 下发现 cat 后时乱码<br>发现 windows 下直接创建 link 会怎样</p><h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><blockquote><p><a href="https://wangchujiang.com/linux-command/c/ln.html" target="_blank" rel="noopener">https://wangchujiang.com/linux-command/c/ln.html</a><br>利用 bash 的 ln 命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ln &#123;$filename1&#125; &#123;$$filename2&#125;</span><br><span class="line">cat &#123;$filename2&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><blockquote><p><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-hardandsymb-links/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/linux/l-cn-hardandsymb-links/index.html</a></p></blockquote><ul><li>硬链接<ul><li>建立硬链接时，在另外的目录或本目录中增加目标文件的一个目录项，这样，一个文件就登记在多个目录中。如图所示的m2.c文件就在目录mub1和liu中都建立了目录项。<br>创建硬链接后，己经存在的文件的I节点号（Inode）会被多个目录文件项使用。一个文件的硬链接数可以在目录的长列表格式的第二列中看到，无额外链接的文件的链接数为l。<br>在默认情况下，ln命令创建硬链接。ln命令会增加链接数，rm命令会减少链接数。一个文件除非链接数为0，否则不会从文件系统中被物理地删除。<br>对硬链接有如下限制：<ul><li>不能对目录文件做硬链接。</li><li>不能在不同的文件系统之间做硬链接。就是说，链接文件和被链接文件必须位于同一个文件系统中。</li></ul></li></ul></li></ul><ul><li><p>符号连接</p><ul><li>符号链接也称为软链接，是将一个路径名链接到一个文件。这些文件是一种特别类型的文件。事实上，它只是一个文本文件（如图中的abc文件），其中包含它提供链接的另一个文件的路径名，如图中虚线箭头所示。另一个文件是实际包含所有数据的文件。所有读、写文件内容的命令被用于符号链接时，将着链接方向前进来访问实际的文件。<br>与硬链接不同的是，符号链接确实是一个新文件，当然它具有不同的I节点号；而硬链接并没有建立新文件。<br>符号链接没有硬链接的限制，可以对目录文件做符号链接，也可以在不同文件系统之间做符号链接。<br>用ln -s命令建立符号链接时，源文件最好用绝对路径名。这样可以在任何工作目录下进行符号链接。而当源文件用相对路径时，如果当前的工作路径与要创建的符号链接文件所在路径不同，就不能进行链接。<br>符号链接保持了链接与源文件或目录之间的区别：<br>删除源文件或目录，只删除了数据，不会删除链接。一旦以同样文件名创建了源文件，链接将继续指向该文件的新数据。<br>在目录长列表中，符号链接作为一种特殊的文件类型显示出来，其第一个字母是l。符号链接的大小是其链接文件的路径名中的字节数。<br>当用ln -s命令列出文件时，可以看到符号链接名后有一个箭头指向源文件或目录，例如lrwxrwxrwx … 14 jun 20 10:20 /etc/motd-&gt;/original_file其中，表示“文件大小”的数字“14”恰好说明源文件名original_file由14个字符构成。</li></ul></li><li><p>软连接不会更新文件，尽量写绝对路径。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
      <category term="note" scheme="https://hackettyu.com/categories/note/"/>
    
    
      <category term="linux" scheme="https://hackettyu.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>命令行开启 | 关闭显卡</title>
    <link href="https://hackettyu.com/181004_3/"/>
    <id>https://hackettyu.com/181004_3/</id>
    <published>2018-10-04T06:00:00.000Z</published>
    <updated>2018-10-16T08:02:08.616Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>寻找一种命令行开关驱动的方式以及关闭独显省电。</p><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><h3 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h3><blockquote><p>安装 devcon :<br><a href="https://docs.microsoft.com/zh-cn/windows-hardware/drivers/download-the-wdk" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/windows-hardware/drivers/download-the-wdk</a></p></blockquote><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>管理员运行，进入你的安装路径（<code>C:\Program Files (x86)\Windows Kits\10\Tools\x64&gt;</code>这是 64 位的）下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">devcon find * &gt; driver.txt</span><br></pre></td></tr></table></figure></p><p>例如要关闭 NVIDIA 显卡：</p><p><code>PCI\VEN_10DE&amp;DEV_139B&amp;SUBSYS_01521558&amp;REV_A2\4&amp;BED9AB3&amp;0&amp;0008: NVIDIA GeForce GTX 960M</code></p><p>截取一段编号查询并查询到唯一驱动：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">devcon find *VEN_10DE</span><br></pre></td></tr></table></figure></p><p>运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 关闭</span><br><span class="line">devcon disacble *VEN_10DE</span><br><span class="line">// 打开</span><br><span class="line">// devcon enable *VEN_10DE</span><br></pre></td></tr></table></figure></p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>查询服务的命令 <code>sc</code>:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// New-Alias -Name Run-SC -Value &apos;C:\Windows\System32\sc.exe&apos;</span><br><span class="line">// Run-SC query ALG</span><br><span class="line">sc query type= driver | findstr NVIDIA</span><br></pre></td></tr></table></figure></p><p>打开图形驱动管理界面：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start devmgmt.msc</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
      <category term="note" scheme="https://hackettyu.com/categories/note/"/>
    
    
      <category term="command" scheme="https://hackettyu.com/tags/command/"/>
    
  </entry>
  
  <entry>
    <title>vim 配置</title>
    <link href="https://hackettyu.com/181004_4/"/>
    <id>https://hackettyu.com/181004_4/</id>
    <published>2018-10-04T06:00:00.000Z</published>
    <updated>2018-10-16T08:42:13.133Z</updated>
    
    <content type="html"><![CDATA[<h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><ul><li><p>查找 vim 配置文件在哪</p><ul><li>:version</li><li>echo $vim</li></ul></li><li><p>vim 插件管理器 bundle</p><ul><li>PluginInstall 安装插件，要先写配置文件，bash 的 vim 配置文件在 Git 安装路径里面。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
      <category term="log" scheme="https://hackettyu.com/categories/log/"/>
    
    
      <category term="profile" scheme="https://hackettyu.com/tags/profile/"/>
    
      <category term="vim" scheme="https://hackettyu.com/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>命令行下 powershell 提权</title>
    <link href="https://hackettyu.com/181004_2/"/>
    <id>https://hackettyu.com/181004_2/</id>
    <published>2018-10-04T04:00:00.000Z</published>
    <updated>2018-10-16T08:00:46.070Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>windows 下每次打开一个普通 cli 后发现要按 [win + X + A] 组合键才能打开管理员 cli ，感觉很麻烦，然后在网速查到了这个方法。</p><h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><p>在普通 powershell 下输入下面的命令即可提权：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Start-Process -verb runas &quot;C:\Windows\SysWOW64\WindowsPowerShell\v1.0\Powershell.exe&quot;</span><br></pre></td></tr></table></figure></p><p>后面的路径根据实际的路径修改，最好用任务管理器查看系统使用的那个，系统内可能有几个 powershell 程序。</p><h2 id="入门篇"><a href="#入门篇" class="headerlink" title="入门篇"></a>入门篇</h2><blockquote><p><a href="https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/new-alias?view=powershell-6" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/new-alias?view=powershell-6</a><br><a href="https://docs.microsoft.com/zh-cn/powershell/module/microsoft.powershell.core/about/about_functions?view=powershell-6" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/powershell/module/microsoft.powershell.core/about/about_functions?view=powershell-6</a></p></blockquote><p>其实这样输入有点麻烦，bash 有 alias 这样的命令的给命令起别名， cmd 有doskey 这样的命令，而 powershell 的是 Set-Alias 。<br>下面的命令分别是添加、获取和删除别名：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Set-Alias &#123;$alias&#125; &#123;$command&#125;</span><br><span class="line">Get-Alias | findstr &#123;$alias&#125;</span><br><span class="line">Remove-Item alias:&#123;$alias&#125;</span><br></pre></td></tr></table></figure></p><p>用 Set-Alias 找不到能传参的方式，用了函数的方式，用法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Function FuncName （args[]）</span><br><span class="line">&#123;</span><br><span class="line">      code;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>实际命令如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Function fuck &#123;Start-Process -verb runas &quot;C:\Windows\System32\WindowsPowerShell\v1.0\Powershell.exe&quot;&#125;</span><br><span class="line">Set-Alias sudo fuck</span><br></pre></td></tr></table></figure></p><p>删除函数如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del Function:&#123;$your function&#125;</span><br></pre></td></tr></table></figure></p><h2 id="进阶篇"><a href="#进阶篇" class="headerlink" title="进阶篇"></a>进阶篇</h2><blockquote><p><a href="https://technet.microsoft.com/zh-CN/library/hh847748.aspx" target="_blank" rel="noopener">https://technet.microsoft.com/zh-CN/library/hh847748.aspx</a></p></blockquote><p>上面的方法可以使用但是，关闭程序后旧失效了，找了一种方法把脚本写入全局。<br>找到全局设置文件 Microsoft.PowerShell_profile.ps1 ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Get-Variable profile | Format-List</span><br></pre></td></tr></table></figure></p><p>如果没有自己创建一个，写入下面的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Function fuck &#123;Start-Process -verb runas &quot;C:\Windows\System32\WindowsPowerShell\v1.0\Powershell.exe&quot;&#125;</span><br><span class="line">Set-Alias sudo fuck</span><br></pre></td></tr></table></figure></p><p>保存后发现无法加载，因为默认不加载外部脚本，管理员权限下 powershell 运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set-ExecutionPolicy RemoteSigned</span><br></pre></td></tr></table></figure></p><blockquote><p><strong>REMOTESIGNED</strong><br>脚本可以运行。这是 Windows Server 2012 R2 中的默认执行策略。<br>要求从 Internet 下载的脚本和配置文件（包括电子邮件和即时消息程序）具有受信任的发布者的数字签名。<br>不要求你在本地计算机上编写的脚本（不是从 Internet 下载的）具有数字签名。<br>如果脚本已被取消阻止（比如通过使用 Unblock-File cmdlet），则运行从 Internet 下载但未签名的脚本。<br>存在运行来自 Internet 之外的源的未签名脚本和已签名但却是恶意的脚本的风险。</p></blockquote><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>cmd 提权：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">runas /user:hackett_yu@outlook.com cmd</span><br><span class="line">doskey sudo=runas /user:&#123;$username&#125; cmd</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
      <category term="note" scheme="https://hackettyu.com/categories/note/"/>
    
    
      <category term="command" scheme="https://hackettyu.com/tags/command/"/>
    
      <category term="powershell" scheme="https://hackettyu.com/tags/powershell/"/>
    
      <category term="script" scheme="https://hackettyu.com/tags/script/"/>
    
  </entry>
  
  <entry>
    <title>中文技术文档的写作规范</title>
    <link href="https://hackettyu.com/181004_1/"/>
    <id>https://hackettyu.com/181004_1/</id>
    <published>2018-10-04T02:00:00.000Z</published>
    <updated>2018-10-16T07:58:56.232Z</updated>
    
    <content type="html"><![CDATA[<ul><li><blockquote><p><a href="https://github.com/ruanyf/document-style-guide/blob/master/docs/structure.md" target="_blank" rel="noopener">https://github.com/ruanyf/document-style-guide/blob/master/docs/structure.md</a></p></blockquote></li></ul><hr><h2 id="文档体系"><a href="#文档体系" class="headerlink" title="文档体系"></a>文档体系</h2><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p>软件手册是一部完整的书，建议采用下面的结构。</p><ul><li><strong>简介</strong>（Introduction）： [必备] [文件] 提供对产品和文档本身的总体的、扼要的说明</li><li><strong>快速上手</strong>（Getting Started）：[可选] [文件] 如何最快速地使用产品</li><li><strong>入门篇</strong>（Basics）： [必备] [目录] 又称”使用篇“，提供初级的使用教程<ul><li><strong>环境准备</strong>（Prerequisite）：[必备] [文件] 软件使用需要满足的前置条件</li><li><strong>安装</strong>（Installation）：[可选] [文件] 软件的安装方法</li><li><strong>设置</strong>（Configuration）：[必备] [文件] 软件的设置</li></ul></li><li><strong>进阶篇</strong>（Advanced)：[可选] [目录] 又称”开发篇“，提供中高级的开发教程</li><li><strong>API</strong>（Reference）：[可选] [目录|文件] 软件 API 的逐一介绍</li><li><strong>FAQ</strong>：[可选] [文件] 常见问题解答</li><li><strong>附录</strong>（Appendix）：[可选] [目录] 不属于教程本身、但对阅读教程有帮助的内容<ul><li><strong>Glossary</strong>：[可选] [文件] 名词解释</li><li><strong>Recipes</strong>：[可选] [文件] 最佳实践</li><li><strong>Troubleshooting</strong>：[可选] [文件] 故障处理</li><li><strong>ChangeLog</strong>：[可选] [文件] 版本说明</li><li><strong>Feedback</strong>：[可选] [文件] 反馈方式</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
      <category term="digest" scheme="https://hackettyu.com/categories/digest/"/>
    
    
      <category term="others" scheme="https://hackettyu.com/tags/others/"/>
    
  </entry>
  
  <entry>
    <title>vscode 控制台输出编码问题</title>
    <link href="https://hackettyu.com/181003_1/"/>
    <id>https://hackettyu.com/181003_1/</id>
    <published>2018-10-03T02:00:00.000Z</published>
    <updated>2018-10-16T07:56:44.997Z</updated>
    
    <content type="html"><![CDATA[<h2 id="error"><a href="#error" class="headerlink" title="error"></a>error</h2><p>vscode 的 run code 插件无法使用，原因是控制台的编码问题</p><h2 id="usage"><a href="#usage" class="headerlink" title="usage"></a>usage</h2><blockquote><p><a href="https://github.com/formulahendry/vscode-code-runner/issues/241#issuecomment-400633228" target="_blank" rel="noopener">github vscode-code-runner issues</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
      <category term="debug" scheme="https://hackettyu.com/categories/debug/"/>
    
    
      <category term="vscode" scheme="https://hackettyu.com/tags/vscode/"/>
    
  </entry>
  
  <entry>
    <title>解决 chromium 缺少 google api 密钥无法登录问题</title>
    <link href="https://hackettyu.com/181001_7/"/>
    <id>https://hackettyu.com/181001_7/</id>
    <published>2018-10-01T15:00:00.000Z</published>
    <updated>2018-10-16T07:48:08.042Z</updated>
    
    <content type="html"><![CDATA[<p>管理员命令运行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setx GOOGLE_API_KEY “AIzaSyAUoSnO_8k-3D4-fOp-CFopA_NQAkoVCLw”</span><br><span class="line">setx GOOGLE_DEFAULT_CLIENT_ID “6307505647-6knmr84r2pj2leudg3pp1j0h1licd6b9.apps.googleusercontent.com”</span><br><span class="line">setx GOOGLE_DEFAULT_CLIENT_SECRET “rbeWhXTLgU8oLiUeefPsEL9c”</span><br></pre></td></tr></table></figure></p><p>这三行分别是：API密钥、客户端ID、客户端密钥</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
      <category term="debug" scheme="https://hackettyu.com/categories/debug/"/>
    
    
      <category term="chromeium" scheme="https://hackettyu.com/tags/chromeium/"/>
    
  </entry>
  
  <entry>
    <title>m3u8 转 mp4</title>
    <link href="https://hackettyu.com/181001_6/"/>
    <id>https://hackettyu.com/181001_6/</id>
    <published>2018-10-01T10:00:00.000Z</published>
    <updated>2018-10-16T07:51:55.012Z</updated>
    
    <content type="html"><![CDATA[<script src="https://gist.github.com/tzmartin/fb1f4a8e95ef5fb79596bd4719671b5d.js"></script><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ffmpeg -i <span class="string">"http://host/folder/file.m3u8"</span> -bsf:a aac_adtstoasc -vcodec copy -c copy -crf 50 file.mp4</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
      <category term="digest" scheme="https://hackettyu.com/categories/digest/"/>
    
    
      <category term="command" scheme="https://hackettyu.com/tags/command/"/>
    
      <category term="ffmpeg" scheme="https://hackettyu.com/tags/ffmpeg/"/>
    
  </entry>
  
  <entry>
    <title>解决 git LF 和 CFLF 换行问题</title>
    <link href="https://hackettyu.com/181001_1/"/>
    <id>https://hackettyu.com/181001_1/</id>
    <published>2018-10-01T02:00:00.000Z</published>
    <updated>2018-10-16T07:47:21.907Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.autocrlf true</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
      <category term="debug" scheme="https://hackettyu.com/categories/debug/"/>
    
    
      <category term="git" scheme="https://hackettyu.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>JSR 133 FAQ 翻译</title>
    <link href="https://hackettyu.com/180927_3/"/>
    <id>https://hackettyu.com/180927_3/</id>
    <published>2018-09-27T10:00:00.000Z</published>
    <updated>2018-10-16T07:42:37.168Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://xurongyang.github.io/2017/05/20/JSR-133-FAQ%E7%BF%BB%E8%AF%91/" target="_blank" rel="noopener">https://xurongyang.github.io/2017/05/20/JSR-133-FAQ%E7%BF%BB%E8%AF%91/</a><br><a href="https://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html" target="_blank" rel="noopener">https://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html</a></p></blockquote><h2 id="内存模型到底是什么"><a href="#内存模型到底是什么" class="headerlink" title="内存模型到底是什么"></a>内存模型到底是什么</h2><p>在多处理器计算机系统中，处理器一般拥有多层次的内存缓存，内存缓存一方面能够提高访问数据的速度（因为数据离处理器更近了），另一方面能降低总线的流量（因为许多内存操作可以被缓存替代）。内存缓存能极大的提高性能，但是也带来了一些挑战。例如，当两个处理器同时访问同一个内存地址时会发生什么事情？在什么情况下他们能看到相同的值？</p><p>在处理器级别，存储器模型定义了必要和充分的条件，用于知道其他处理器对存储器的写入对于当前处理器是可见的，并且当前处理器的写入对于其他处理器是可见的。一些处理器应用了强一致内存模型，所有的处理器对于同一个内存地址，看到的值都是一样的。其它一些处理器应用了弱一些的内存模型，利用内存屏障来刷新处理器本地缓存，这样处理器就能看到其它处理器的写操作的结果。这些内存屏障通常在lock和unlock操作时执行，它们对于高级程序设计语言是透明的。</p><p>在强一致内存模型下编写程序通常更为容易，因为不需要用到内存屏障。然而，即使是一致性最强的内存模型也经常会用到内存屏障。往往他们的位置都是违反直觉的。处理器设计的最新趋势鼓励了较弱的内存模型，因为它们对缓存一致性的放宽使得可以在多个处理器和更大量的内存中实现更大的可扩展性。</p><p>一个写入操作什么时间对另外一个线程可见的问题部分是由编译器重排序导致的。例如，编译器可能会决定把一个写入操作推迟执行会更加高效。只有不改变程序的语义即可。如果编译器推迟了一个操作，另一个线程直到它真正执行后才会看到操作结果，这反应了缓存的效果（最后半句有点奇怪）。</p><p>此外，写操作也可能会提前，在这种情况下，其它线程可能会提前看到一个写操作发生。所有这些都是特意设计的 - 通过给编译器，运行时或硬件提供灵活性，以最佳顺序在内存模型的范围内执行操作，我们可以实现更高的性能。</p><p>举一个简单的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Class Reordering &#123;</span><br><span class="line">  int x = 0, y = 0;</span><br><span class="line">  public void writer() &#123;</span><br><span class="line">    x = 1;</span><br><span class="line">    y = 2;</span><br><span class="line">  &#125;</span><br><span class="line">  public void reader() &#123;</span><br><span class="line">    int r1 = y;</span><br><span class="line">    int r2 = x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>假设这段代码被两个线程并发执行，并且y读取到的值是2。因为y的写入在x之后，所以程序员可能会认为x的值必定是1。然而，写操作可能被重排序了，如果发生这种情况，可能会先写入y，然后发生两个变量的读取，最后写入x。 结果是r1的值为2，但r2的值为0。</p><p>Java内存模型描述了多线程代码中的哪些行为是合法的，以及线程如何通过内存进行交互。 它描述了程序中变量之间的关系以及在实际计算机系统中存储和检索内存或寄存器的底层细节。 它可以使用各种各样的硬件和各种编译器优化来正确实现。</p><p>Java包括几种语言结构，包括volatile，final和synchronized，它们旨在帮助程序员将程序的并发要求提供给编译器。 Java内存模型定义了volatile和synchronized的行为，更重要的是确保正确同步的Java程序在所有处理器架构上正确运行。</p><p>其它语言有没有内存模型<br>大多数其他编程语言（如C和C ++）并没有直接支持多线程。 这些语言抑制编译器和体系结构中的重排序提供给程序员的保护在很大程度上取决于所使用的线程库（例如pthreads），使用的编译器以及运行代码的平台提供的保证。</p><h2 id="JSR-133讲了什么内容"><a href="#JSR-133讲了什么内容" class="headerlink" title="JSR 133讲了什么内容"></a>JSR 133讲了什么内容</h2><p>自1997年以来，在Java语言规范第17章定义的Java Memory Model中发现了几个严重的缺陷。 这些缺陷允许混淆行为（例如观察到final改变了其值），并且破坏了编译器执行常见优化的能力。</p><p>Java内存模型是一项雄心勃勃的工作; 这是第一次编程语言规范试图并入一个内存模型，可以为各种架构的并发提供一致的语义。 不幸的是，定义一个一致和直观的记忆模型比预期的困难得多。 JSR 133定义了一种用于Java语言的新内存模型，它修复了较早内存模型的缺陷。 为了做到这一点，final和volatile的语义需要改变。</p><p>完整内容可以在 <a href="http://www.cs.umd.edu/users/pugh/java/memoryModel" target="_blank" rel="noopener">The Java Memory Model</a> 找到，but the formal semantics are not for the timid（这句不懂）.It is surprising, and sobering, to discover how complicated seemingly simple concepts like synchronization really are（这句也是）.幸运的是，你不需要了解正式语义的细节 - JSR 133的目标是创建一套语义，为volatile，synchronized和final提供了一个直观的框架。</p><h2 id="JSR-133的目标包括："><a href="#JSR-133的目标包括：" class="headerlink" title="JSR 133的目标包括："></a>JSR 133的目标包括：</h2><ul><li>保持现有的安全保障，如类型安全，加强其他。 例如，变量值可能不会被创建为某个没有赋值给它的值：由某个线程观察到的变量的每个值必须是由某个线程设置过的值。</li><li>正确同步程序的语义应尽可能简单直观。</li><li>应该定义不完整或不正确同步的程序的语义，以使潜在的安全隐患最小化。（不懂）</li><li>程序员应该能够自信地说明多线程程序如何与内存交互。</li><li>应该可以在广泛的流行硬件架构中设计正确的，高性能的JVM实现。</li><li>应提供初始化安全的新保证。 如果对象被正确构造（这意味着在构造过程中它的引用不会逸出），那么可以看到对该对象的引用的所有线程也将看到在构造函数中设置的final域的值，而不需要同步。</li><li>对已存在的代码有很小的影响</li></ul><h2 id="重排序的含义是什么？"><a href="#重排序的含义是什么？" class="headerlink" title="重排序的含义是什么？"></a>重排序的含义是什么？</h2><p>有许多情况下，程序变量（对象实例字段，类静态字段和数组元素）的访问可能会以与程序指定的不同的顺序执行。 编译器可以按照优化的名义，对指令进行重排序。 数据可以在寄存器，处理器高速缓存和主存储器之间以与程序指定的顺序不同的顺序移动。</p><p>例如，如果线程先写入字段a，然后写入字段b，并且b的值不依赖于a的值，则编译器可以自由地对这些操作进行重新排序，并且缓存可以自由地刷新b的值到内存，在a之前。 有一些潜在的重新排序来源，如编译器，JIT和缓存。</p><p>编译器，运行时和硬件会创造一个as-if-serial语义的错觉，这意味着在一个单线程程序中，该程序不应该能够观察到重排序的影响。 然而，重排序可能会在不正确同步的多线程程序中发挥作用，其中一个线程能够观察到其他线程的影响，并且可能能够检测到该变量访问以与代码顺序不同的方式显示给其他线程。</p><p>大多数时候，一个线程不在乎其它线程在做什么。 但是，如果它在乎，就需要用到同步。</p><h2 id="旧内存模型有什么问题？"><a href="#旧内存模型有什么问题？" class="headerlink" title="旧内存模型有什么问题？"></a>旧内存模型有什么问题？</h2><p>旧的内存模型有几个严重的问题。它很难理解，因此被广泛的违背。例如，旧的内存模型在很多情况下都没有允许在大多数JVM中应用的重排序措施。这带来了JSR 133的形成。</p><p>例如，一个广泛认同的观点是，如果使用final，则线程之间的同步是不必要的，以保证另一个线程将看到该字段的值。 虽然这是一个合理的假设和一个明智的行为，实际上我们想要的东西如何工作，在旧的记忆模式下，根本不是这么做的。 旧的内存模型中没有任何内容表明它处理final字段与任何其他字段不同 - 意思是同步是确保所有线程都看到由构造函数编写的最终字段的值的唯一方法。 因此，线程可能会看到该字段的默认值，然后在稍后的时间内看到其构造的值。 这意味着，例如，像String这样的不可变对象似乎可以改变它们的值 - 这是一个令人不安的现象。</p><p>旧的内存模型允许volatile与非volatile的读写操作进行重排序，这与大多数开发人员对volatile的直觉不一致，从而导致混乱。</p><p>最后，正如我们将看到的那样，程序员对程序错误同步时可能会发生什么的直觉通常是错误的。 JSR-133的目标之一是提请注意到这一事实。</p><h2 id="“非正确同步”是什么意思？"><a href="#“非正确同步”是什么意思？" class="headerlink" title="“非正确同步”是什么意思？"></a>“非正确同步”是什么意思？</h2><p>不正确同步的代码对于不同人的含义不一样。 当我们谈到在Java内存模型的上下文中错误地同步的代码时，我们的意思是任何代码</p><p>有一个线程写入一个变量<br>有另一个线程读取相同的变量<br>写入和读取没有用同步操作来排序<br>当这些规则被违反时，我们说我们在这个变量上有一个数据竞争。 具有数据竞争的程序是一个不正确同步的程序。</p><h2 id="Synchronization同步操作做了什么"><a href="#Synchronization同步操作做了什么" class="headerlink" title="Synchronization同步操作做了什么"></a>Synchronization同步操作做了什么</h2><p>同步有几个方面。 最容易理解的是互斥 - 只有一个线程可以拿到一个监视器锁，因此在监视器锁上同步意味着一旦一个线程进入被监视器锁保护的同步块，则没有其他线程可以进入该监视器锁保护的块，直到第一个线程退出同步块。</p><p>但是不仅仅是互斥访问，Synchronization同步确保在同步块之前或期间，线程的内存写入以可预测的方式显示给同一监视器上同步的其他线程。 在我们退出同步程序段后，我们释放监视器锁，该监视器锁具有将缓存刷新到内存的作用，使得此线程所做的写入对其他线程可见。 在我们可以进入同步块之前，我们需要获取监视器锁，该监视器锁具有使本地处理器缓存无效的效果，以便从内存重新加载变量。 然后，我们将能够看到所有的上一版本都可以看到的写入。</p><p>在缓存方面进行讨论，可能听起来好像这些问题只影响多处理器机器。 然而，可以在单个处理器上轻松看到重新排序的效果。 例如，编译器不会将acquire之后的代码移动到它之前，也不会把release之前的代码移动到它之后。当我们说acquire和release对缓存的操作时，我们忽略了很多的细节内容。</p><p>新的内存模型语义在内存操作（读取字段，写入字段，加锁，解锁）和其他线程操作（启动和连接）上创建了一些偏序规则，其中一些操作在其他操作之前发生。 当一个动作发生在另一个动作之前，第一个被保证在第二个之前被执行并且结果对其可见。 此排序的规则如下：</p><ul><li>单线程中是完全按照代码顺序执行的</li><li>监视器的解锁操作发生在该监视器随后的加锁操作之前</li><li>对volatile字段的写入发生在该volatile字段每次后续读取之前</li><li>线程的start操作发生于该线程内的任何一行代码之前</li><li>一个线程内的所有操作都发生在join了这个线程的线程之前<br>这意味着一个线程在退出同步块之前的所有内存操作对于任何其它进入该同步块的线程都是可见的，因为所有的内存操作都发生在release之前，release发生在acquire之前。</li></ul><p>另外一个含义是，下面的这个被许多人用作内存屏障的操作不起作用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">synchronized (new Object()) &#123;&#125;</span><br></pre></td></tr></table></figure></p><p>这实际上没有任何效果，你的编译器可以完全删除它，因为编译器知道没有其他线程将在同一个监视器上同步。如果一个线程想看到另外一个线程的结果，就必须设置一个happens before规则。</p><p>重要提示：两个线程必须在同一个监视器锁上进行同步，这样才能设置happens before规则。如果线程A在X上同步，线程B在Y上同步，这样是没有效果的。release和acquire必须匹配，否则会存在数据竞争的问题。</p><h2 id="不可见变量如何看起来修改了它的值"><a href="#不可见变量如何看起来修改了它的值" class="headerlink" title="不可见变量如何看起来修改了它的值"></a>不可见变量如何看起来修改了它的值</h2><p>最好的例子是String类的一个实现。</p><p>字符串可以实现为具有三个字段的对象 - 字符数组，该数组中的偏移量和长度。 以这种方式实现String的理由，而不是仅使用字符数组，它允许多个String和StringBuffer对象共享相同的字符数组，并避免额外的对象分配和复制。 所以，例如，String.substring（）方法可以通过创建一个新的字符串来实现，该字符串与原始的String共享相同的字符数组，并且在长度和偏移量字段中只是不同。 对于字符串，这些字段都是final字段。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s1 = &quot;/usr/tmp&quot;;</span><br><span class="line">String s2 = s1.substring(4);</span><br></pre></td></tr></table></figure></p><p>字符串s2的偏移量为4，长度为4.但是，在旧内存模型下，另一个线程可以将偏移量看作默认值为0，然后看到正确的值为4， 它将显示为字符串“/usr”更改为“/tmp”。</p><p>旧内存模型允许这种行为，几个JVM禁止了这些行为，在新的内存模型下，这种行为是违法的。</p><h2 id="新的内存模型下final域的工作原理是怎样的？"><a href="#新的内存模型下final域的工作原理是怎样的？" class="headerlink" title="新的内存模型下final域的工作原理是怎样的？"></a>新的内存模型下final域的工作原理是怎样的？</h2><p>对象的final字段的值在其构造函数中设置。假设对象被正确构造，一旦构造完成，在构造函数中分配的final字段的值将对所有其他线程都是可见的，不需要同步。 此外，final字段引用的任何其他对象或数组的值将与final字段保持同步更新。</p><p>对象被正确构造是什么意思？ 这仅仅意味着在构造过程中，不允许正在构造的对象的引用“逃脱”。 （参见安全构造技术的例子）换句话说，不要对正在构造的对象引用另外一个线程可能看到的对象; 不要将其分配给静态字段，不要将其注册为与任何其他对象的监听器，等等。 这些任务应该在构造函数完成之后完成，而不是在构造函数中完成。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class FinalFieldExample &#123;</span><br><span class="line">  final int x;</span><br><span class="line">  int y;</span><br><span class="line">  static FinalFieldExample f;</span><br><span class="line">  public FinalFieldExample() &#123;</span><br><span class="line">    x = 3;</span><br><span class="line">    y = 4;</span><br><span class="line">  &#125;</span><br><span class="line">  static void writer() &#123;</span><br><span class="line">    f = new FinalFieldExample();</span><br><span class="line">  &#125;</span><br><span class="line">  static void reader() &#123;</span><br><span class="line">    if (f != null) &#123;</span><br><span class="line">      int i = f.x;</span><br><span class="line">      int j = f.y;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的类是一个使用final字段的例子。 线程执行reader保证为f.x看到值3，因为它是final的。不能保证为y看到值4，因为它不是final的。 如果FinalFieldExample的构造函数如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public FinalFieldExample() &#123; // bad!</span><br><span class="line">  x = 3;</span><br><span class="line">  y = 4;</span><br><span class="line">  // bad construction - allowing this to escape</span><br><span class="line">  global.obj = this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>那么从<code>global.obj</code>读取this的线程不能保证为x看到3。</p><p>能看到正确构造的字段值的能力是很好的，但是如果字段本身是引用，那么你还希望你的代码可以看到它指向的对象（或数组）的最新值。 如果你的领域是一个final域，这也是保证的。 所以，你可以有一个final指向数组的指针，而不用担心其他线程看到数组的引用是正确的，但数组的内容不正确。Again, by “correct” here, we mean “up to date as of the end of the object’s constructor”, not “the latest value available”.</p><p>现在，说完所有这一切，如果在一个线程构造一个不可变对象（即只包含final字段的对象）之后，你想要确保所有其他线程都能看到正确的值，你通常还需要使用同步。 没有其他方法来确保，例如，第二个线程将会看到对不可变对象的引用。程序从final字段获得的保证应该非常小心，深入细心地了解如何在代码中管理并发性。</p><p>用JNI修改final字段的值，这样的行为没有具体定义。</p><h2 id="volatile做了什么"><a href="#volatile做了什么" class="headerlink" title="volatile做了什么"></a>volatile做了什么</h2><p>volatile字段是用于在线程之间通信状态的特殊字段。每个读取的volatile的线程都会看到最后写入volatile的值; 实际上，它们被程序员设计为不会因为缓存或者重排序看不到最新的值的字段。禁止编译器和运行时环境在寄存器中分配volatile变量。 他们还必须确保在写入之后，将它们从缓存中刷新到内存，以便它们可以立即变得对其他线程可见。 类似地，在读取volatile字段之前，缓存必须被设置为无效，使得内存（而不是本地处理器高速缓存）中的值是最新的值。对volatile变量的访问重新排序也有其他限制。</p><p>在旧的内存模型下，volatile变量之间是不可以重排序的，但是和普通变量之间是可以重排序的，这破坏了volatile对于线程间传递信号的有用性。</p><p>在新的内存模型下，volatile变量之间还是不可以重排序，但是和普通变量之间也不可以重排序了。写入volatile的值和释放synchronized锁的内存效果是一样的，读取volatile的值和synchronized加锁的内存效果是一样的。实际上，因为新的存储器模型对于其他字段和volatile字段的重排序进行了更加严格的约束，无论是不是volatile变量，线程A在写入volatile字段f时可见的任何东西对于线程B在读取f时都是可见的。</p><p>下面是使用volatile的一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class VolatileExample &#123;</span><br><span class="line">  int x = 0;</span><br><span class="line">  volatile boolean v = false;</span><br><span class="line">  public void writer() &#123;</span><br><span class="line">    x = 42;</span><br><span class="line">    v = true;</span><br><span class="line">  &#125;</span><br><span class="line">  public void reader() &#123;</span><br><span class="line">    if (v == true) &#123;</span><br><span class="line">      //uses x - guaranteed to see 42.</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>假设一个线程正在调用writer，另一个线程是调用reader。 对v的写入器会把x的值写入到内存，并且v从内存中获取该值。 因此，如果读者看到v的值为true，那么也可以保证看到之前发生的写入42。 在旧的记忆模型下不是这样。 如果v不是volatile的，那么编译器可以对写入器中的写入进行重新排序，读者对x的读取可能会看到0。</p><p>volatile的语义被大大加强，几乎到达了synchronized的水平。对于可见性来说，volatile操作几乎和synchronized一样。</p><p>重要提示：和synchronized一样，必须用同一个volatile才能保证可见性。</p><p>新的内存模型是否修复了“双重锁定”问题？<br>（臭名昭着的）双重检查锁定成语（也称为多线程单例模式）是一种技巧，旨在支持延迟初始化，同时避免同步的开销。在非常早期的JVM中，同步非常缓慢，开发人员急于删除它 - 也许太渴望了。双重锁定的模式如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// double-checked-locking - don&apos;t do this!</span><br><span class="line">private static Something instance = null;</span><br><span class="line">public Something getInstance() &#123;</span><br><span class="line">  if (instance == null) &#123;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">      if (instance == null)</span><br><span class="line">        instance = new Something();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这看起来很聪明 - 在公共代码路径上避免了同步。 它只有一个问题 - 它没有作用。为什么没有作用？最明显的原因是初始化实例和对实例字段的写入可以由编译器或缓存重新排序，这将具有返回看起来是部分构造的对象的效果。 结果将是我们读取一个未初始化的对象。 还有很多其他原因能说明为什么这是错误的。没有办法使用旧的Java内存模型进行修复。更多信息可以查看：Double-checked locking: Clever, but broken和The “Double Checked Locking is broken” declaration</p><p>许多人认为使用volatile关键字会消除在尝试使用双重检查锁定模式时出现的问题。 在1.5之前的JVM中，volatile不会确保它有效。 在新的内存模型下，使实例字段volatile将“修复”双重锁定的问题，因为在构造和读取之间存在happens before关系。</p><p>用另外一种方式更好：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private static class LazySomethingHolder &#123;</span><br><span class="line">  public static Something something = new Something();</span><br><span class="line">&#125;</span><br><span class="line">public static Something getInstance() &#123;</span><br><span class="line">  return LazySomethingHolder.something;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由于静态字段的初始化保证，该代码保证是正确的; 如果在静态初始化程序中设置了一个字段，那么它将被保证被正确地显示给访问该类的任何线程。</p><p>对虚拟机从业者<br>你应该看 <a href="http://gee.cs.oswego.edu/dl/jmm/cookbook.html" target="_blank" rel="noopener">The JSR-133 Cookbook for Compiler Writers</a></p><h2 id="为什么要关心内存模型？"><a href="#为什么要关心内存模型？" class="headerlink" title="为什么要关心内存模型？"></a>为什么要关心内存模型？</h2><p>你为什么要关心？ 并发错误很难调试。他们经常不出现在测试中，需要等待，直到你的程序在高负载下运行，并且难以重现。 你最好提前花费额外的努力，以确保您的程序正确同步; 虽然这不容易，但比尝试调试严重同步的应用程序要容易得多。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
      <category term="digest" scheme="https://hackettyu.com/categories/digest/"/>
    
    
      <category term="java" scheme="https://hackettyu.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>synchronized 实现</title>
    <link href="https://hackettyu.com/180927_2/"/>
    <id>https://hackettyu.com/180927_2/</id>
    <published>2018-09-27T08:00:00.000Z</published>
    <updated>2018-10-16T07:41:37.859Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://xurongyang.github.io/" target="_blank" rel="noopener">https://xurongyang.github.io/</a></p></blockquote><h2 id="synchronized-用法"><a href="#synchronized-用法" class="headerlink" title="synchronized 用法"></a>synchronized 用法</h2><p>synchronized是Java语言中用于线程间并发互斥访问的关键字，通常有两种用法。</p><h2 id="synchronized-修饰对象"><a href="#synchronized-修饰对象" class="headerlink" title="synchronized 修饰对象"></a>synchronized 修饰对象</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void method() &#123;</span><br><span class="line">  synchronized (someObject) &#123;</span><br><span class="line">    // code</span><br><span class="line">  &#125;</span><br><span class="line">  // no effect</span><br><span class="line">  synchronized (new Object()) &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当synchronized修饰的是对象时，实际上对synchronized块的代码加了一个对象锁，只有获取到这个锁才能执行synchronized块的代码，达到了互斥访问的效果。</p><p>倘若synchronized修饰的是new Object()呢？因为每次执行到此处时都会对这个新创建出来的对象加锁，而每次加锁的对象又都不相同，所以没有办法达到互斥访问的目的。</p><h2 id="synchronized-修饰方法"><a href="#synchronized-修饰方法" class="headerlink" title="synchronized 修饰方法"></a>synchronized 修饰方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public synchronized method1() &#123;&#125;</span><br><span class="line">public static synchronized method2() &#123;&#125;</span><br></pre></td></tr></table></figure><p>synchronized修饰方法需要区分修饰的是实例方法还是类方法，倘若修饰的是实例方法的话，那么synchronized加锁的对象就是对应的类实例，倘若修饰的是类方法的话，那么synchronized加锁的对象就是该类的Class对象。</p><p>synchronized的字节码表示<br>synchronized作为一个关键字在代码层面就是这样了，下面我们分析下它在字节码层面的表示。先看一段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class SyncCodeBlock &#123;</span><br><span class="line">   public int i;</span><br><span class="line">   public void syncTask()&#123;</span><br><span class="line">       //同步代码库</span><br><span class="line">       synchronized (this)&#123;</span><br><span class="line">           i++;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过javap反编译，得到的字节码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Compiled from &quot;SyncCodeBlock.java&quot;</span><br><span class="line">public class SyncCodeBlock &#123;</span><br><span class="line">  public int i;</span><br><span class="line">  public SyncCodeBlock();</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0       </span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       4: return        </span><br><span class="line">  public void syncTask();</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0       </span><br><span class="line">       1: dup           </span><br><span class="line">       2: astore_1      </span><br><span class="line">       3: monitorenter  </span><br><span class="line">       4: aload_0       </span><br><span class="line">       5: dup           </span><br><span class="line">       6: getfield      #2                  // Field i:I</span><br><span class="line">       9: iconst_1      </span><br><span class="line">      10: iadd          </span><br><span class="line">      11: putfield      #2                  // Field i:I</span><br><span class="line">      14: aload_1       </span><br><span class="line">      15: monitorexit   </span><br><span class="line">      16: goto          24</span><br><span class="line">      19: astore_2      </span><br><span class="line">      20: aload_1       </span><br><span class="line">      21: monitorexit   </span><br><span class="line">      22: aload_2       </span><br><span class="line">      23: athrow        </span><br><span class="line">      24: return        </span><br><span class="line">    Exception table:</span><br><span class="line">       from    to  target type</span><br><span class="line">           4    16    19   any</span><br><span class="line">          19    22    19   any</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对上面的代码做个简化，去掉与synchronized没关系的逻辑，简化版如下 ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">3: monitorenter  //进入同步方法</span><br><span class="line">//..........省略其他  </span><br><span class="line">15: monitorexit   //退出同步方法</span><br><span class="line">16: goto          24</span><br><span class="line">//省略其他.......</span><br><span class="line">21: monitorexit //退出同步方法</span><br></pre></td></tr></table></figure></p><p>当执行monitorenter指令时，会尝试获取对象的锁，如果该对象锁在执行前没有被锁定或者当前线程已经拥有了该对象的锁，就把锁的计数器加一。相应的，在执行monitorexit指令时会将锁计数器减一，当锁计数器值为0时，锁就被释放。如果获取锁失败，该线程就要阻塞等待，知道对象锁被另外一个线程释放。</p><p>值得注意的是编译器将会确保无论方法通过何种方式完成，方法中调用过的每条 monitorenter 指令都有执行其对应 monitorexit 指令，而无论这个方法是正常结束还是异常结束。为了保证在方法异常完成时 monitorenter 和 monitorexit 指令依然可以正确配对执行，编译器会自动产生一个异常处理器，这个异常处理器声明可处理所有的异常，它的目的就是用来执行 monitorexit 指令。从字节码中也可以看出多了一个monitorexit指令，它就是异常结束时被执行的释放monitor 的指令。</p><p>对于synchronized修饰的是方法的情况，在反编译的字节码中并没有monitorenter和monitorexit指令，字节码中的方法申明和代码中保持一致，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static synchronized void syncTask();</span><br><span class="line">  Code:</span><br><span class="line">     0: getstatic     #2                  // Field i:I</span><br><span class="line">     3: iconst_1      </span><br><span class="line">     4: iadd          </span><br><span class="line">     5: putstatic     #2                  // Field i:I</span><br><span class="line">     8: return</span><br></pre></td></tr></table></figure></p><p>其实无论字节码中是monitorenter也好，还是monitorexit也好，都只是告知虚拟机进行锁操作的标志。</p><h2 id="synchronized锁优化"><a href="#synchronized锁优化" class="headerlink" title="synchronized锁优化"></a>synchronized锁优化</h2><h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><p>在 HotSpot 虚拟机中，对象在内存中存储布局分为 3 块区域：对象头（Header）、实例数据（Instance Data）、对齐填充。<br><img src="https://xurongyang.github.io/images/java-object.png" alt="image"></p><p>HotSpot 虚拟机的对象头包括两部分（非数组对象）信息，如下图所示：<br><img src="https://xurongyang.github.io/images/java-object-header.png" alt="images"></p><ul><li>第一部分用于存储对象自身的运行时数据，如哈希码（HashCode）、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳、对象分代年龄，这部分信息称为“Mark Word”；Mark Word 被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，它会根据自己的状态复用自己的存储空间。</li><li>第二部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例；</li><li>如果对象是一个 Java 数组，那在对象头中还必须有一块用于记录数组长度的数据。因为虚拟机可以通过普通 Java 对象的元数据信息确定 Java 对象的大小，但是从数组的元数据中无法确定数组的大小。<br>这部分数据的长度在 32 位和 64 位的虚拟机（未开启压缩指针）中分别为 32bit 和 64bit。</li></ul><p>在 32 位系统下，存放 Class 指针的空间大小是 4 字节，Mark Word 空间大小也是4字节，因此头部就是 8 字节，如果是数组就需要再加 4 字节表示数组的长度，如下表所示：</p><p><img src="https://xurongyang.github.io/images/java-object-header-size.png" alt="java-object-header-size"></p><h3 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h3><p>实例数据部分是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。</p><p>这部分的存储顺序会受到虚拟机分配策略参数（FieldsAllocationStyle）和字段在 Java 源码中定义顺序的影响。</p><h3 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h3><p>对齐填充不是必然存在的，没有特别的含义，它仅起到占位符的作用。</p><p>由于 HotSpot VM 的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，也就是说对象的大小必须是 8 字节的整数倍。对象头部分是 8 字节的倍数，所以当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>偏向锁是Java 6之后加入的新锁，它是一种针对加锁操作的优化手段，经过研究发现，在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，因此为了减少同一线程获取锁(会涉及到一些CAS操作,耗时)的代价而引入偏向锁。偏向锁的核心思想是，如果一个线程获得了锁，那么锁就进入偏向模式，此时Mark Word 的结构也变为偏向锁结构，当这个线程再次请求锁时，无需再做任何同步操作，即获取锁的过程，这样就省去了大量有关锁申请的操作，从而也就提供程序的性能。所以，对于没有锁竞争的场合，偏向锁有很好的优化效果，毕竟极有可能连续多次是同一个线程申请相同的锁。但是对于锁竞争比较激烈的场合，偏向锁就失效了，因为这样场合极有可能每次申请锁的线程都是不相同的，因此这种场合下不应该使用偏向锁，否则会得不偿失，需要注意的是，偏向锁失败后，并不会立即膨胀为重量级锁，而是先升级为轻量级锁。下面我们接着了解轻量级锁。</p><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>倘若偏向锁失败，虚拟机并不会立即升级为重量级锁，它还会尝试使用一种称为轻量级锁的优化手段(1.6之后加入的)，此时Mark Word 的结构也变为轻量级锁的结构。轻量级锁能够提升程序性能的依据是“对绝大部分的锁，在整个同步周期内都不存在竞争”，注意这是经验数据。需要了解的是，轻量级锁所适应的场景是线程交替执行同步块的场合，如果存在同一时间访问同一锁的场合，就会导致轻量级锁膨胀为重量级锁。</p><h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。这是基于在大多数情况下，线程持有锁的时间都不会太长，如果直接挂起操作系统层面的线程可能会得不偿失，毕竟操作系统实现线程之间的切换时需要从用户态转换到核心态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，因此自旋锁会假设在不久将来，当前的线程可以获得锁，因此虚拟机会让当前想要获取锁的线程做几个空循环(这也是称为自旋的原因)，一般不会太久，可能是50个循环或100循环，在经过若干次循环后，如果得到锁，就顺利进入临界区。如果还不能获得锁，那就会将线程在操作系统层面挂起，这就是自旋锁的优化方式，这种方式确实也是可以提升效率的。最后没办法也就只能升级为重量级锁了。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.cnblogs.com/zhengbin/p/6490953.html" target="_blank" rel="noopener">VM——深入分析对象的内存布局</a><br><a href="http://blog.csdn.net/javazejian/article/details/72828483" target="_blank" rel="noopener">深入理解 Java 并发之 synchronized 实现原理</a></p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
      <category term="digest" scheme="https://hackettyu.com/categories/digest/"/>
    
    
      <category term="java" scheme="https://hackettyu.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>代码行统计</title>
    <link href="https://hackettyu.com/180927_1/"/>
    <id>https://hackettyu.com/180927_1/</id>
    <published>2018-09-27T04:00:00.000Z</published>
    <updated>2018-10-16T07:34:49.666Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ cloc cloc/</span><br><span class="line">     465 text files.</span><br><span class="line">     427 unique files.</span><br><span class="line">     251 files ignored.</span><br><span class="line"></span><br><span class="line">http://cloc.sourceforge.net v 1.64  T=1.72 s (240.3 files/s, 16069.0 lines/s)</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">Language                     files          blank        comment           code</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">Java                           234           2277           1889          10399</span><br><span class="line">Javascript                       9            122            175           2756</span><br><span class="line">JSP                             33            176             65           2313</span><br><span class="line">HTML                            18            164             24           2001</span><br><span class="line">Python                          57            441            712           1468</span><br><span class="line">C++                             12             14             15            984</span><br><span class="line">XML                             39            109             75            801</span><br><span class="line">Bourne Shell                     2             42             44            258</span><br><span class="line">DOS Batch                        4             51              4            134</span><br><span class="line">CSS                              2             20             31             59</span><br><span class="line">JSON                             2              0              0             22</span><br><span class="line">Groovy                           2              7             15             20</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">SUM:                           414           3423           3049          21215</span><br><span class="line">-------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
      <category term="log" scheme="https://hackettyu.com/categories/log/"/>
    
    
      <category term="others" scheme="https://hackettyu.com/tags/others/"/>
    
  </entry>
  
  <entry>
    <title>英语技巧</title>
    <link href="https://hackettyu.com/180921/"/>
    <id>https://hackettyu.com/180921/</id>
    <published>2018-09-21T04:00:00.000Z</published>
    <updated>2018-10-16T07:32:50.524Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="http://language.chinadaily.com.cn/trans/2009-12/18/content_9201156.htm" target="_blank" rel="noopener">http://language.chinadaily.com.cn/trans/2009-12/18/content_9201156.htm</a></p></blockquote><p>英译汉的翻译方法和技巧是建立在英汉两种语言的对比之上的。这两种语言在词汇和句法方面的一些表达手段上各有其特点。语序调整主要指词序、句序两方面的调整。</p><p>首先我们谈谈词序的调整。</p><p>英汉语句中的主要成分主语、谓语、宾语或表语的词序基本上是一致的，但各种定语的位置和各种状语的次序在英、汉语言中则有同有异。汉语说“他正在卧室里睡觉”，而在英语中却说He is sleeping in the bedroom.（他睡觉在卧室。）；英语汉语都说“他出生于北京”，”He was born in Beijing”。</p><hr><h2 id="定语位置的调整"><a href="#定语位置的调整" class="headerlink" title="定语位置的调整"></a>定语位置的调整</h2><h3 id="单词作定语。"><a href="#单词作定语。" class="headerlink" title="单词作定语。"></a>单词作定语。</h3><ul><li>英语中，单词作定语时，通常放在它所修饰的名词前，汉语中也大体如此。有时英语中有后置的，译成汉语时一般都前置。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">something important（后置） </span><br><span class="line"></span><br><span class="line">重要的事情（前置）</span><br></pre></td></tr></table></figure><ul><li>如果英语中名词前的定语过多，译文中则不宜完全前置，因为汉语不习惯在名词前用过多的定语。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a little,yellow,ragged beggar（前置） </span><br><span class="line"></span><br><span class="line">一个要饭的，身材矮小，面黄肌瘦，衣衫褴褛。（后置）</span><br></pre></td></tr></table></figure></li></ul><h3 id="短语作定语。"><a href="#短语作定语。" class="headerlink" title="短语作定语。"></a>短语作定语。</h3><ul><li>英语中，修饰名词的短语一般放在名词之后，而汉语则反之，但间或也有放在后面的，视汉语习惯而定。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">their attempt to cross the river（后置）</span><br><span class="line"> 　　</span><br><span class="line">他们渡江的企图（前置）</span><br><span class="line"></span><br><span class="line">the decimal system of counting（后置） 　　</span><br><span class="line"></span><br><span class="line">十进制计算法（后置）</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="状语位置的调整"><a href="#状语位置的调整" class="headerlink" title="状语位置的调整"></a>状语位置的调整</h2><h3 id="单词作状语。"><a href="#单词作状语。" class="headerlink" title="单词作状语。"></a>单词作状语。</h3><ul><li>英语中单词作状语修饰形容词或其他状语时，通常放在它所修饰的形容词或状语的前面，这一点与汉语相同。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">He was very active in class.（前置） 　　</span><br><span class="line"></span><br><span class="line">他在班上很活跃。（前置）</span><br></pre></td></tr></table></figure><ul><li><p>英语中单词作状语修饰动词时，一般放在动词之后，而在汉语里则放在动词之前。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Modern science and technology are developing rapidly．（后置）</span><br><span class="line"></span><br><span class="line">现代科学技术正在迅速发展。（前置）</span><br></pre></td></tr></table></figure></li><li><p>英语中表示程度的状语在修饰状语时可前置也可后置，而在汉语中一般都前置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">He is running fast enough.（后置） 　</span><br><span class="line"></span><br><span class="line">　他跑得够快的了。（前置）</span><br></pre></td></tr></table></figure></li></ul><h3 id="短语作状语。"><a href="#短语作状语。" class="headerlink" title="短语作状语。"></a>短语作状语。</h3><ul><li><p>英语中短语状语可放在被修饰的动词之前或之后，译成汉语时则大多数放在被修饰的动词之前，但也有放在后面的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Seeing this,some of us became very worried．（前置）</span><br><span class="line"></span><br><span class="line">看到这种情况，我们有些人心里很着急。（前置）</span><br><span class="line"></span><br><span class="line">A jeep full sped fast,drenching me in spray．（后置）</span><br><span class="line"></span><br><span class="line">一辆坐满人的吉普车急驶而过，溅了我一身水。（后置）</span><br></pre></td></tr></table></figure></li><li><p>英语中地点状语一般在时间状语之前，而汉语中时间状语则往往放在地点状语之前。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">He was born in Beijing on May 20,1970．（地点在前）</span><br><span class="line"></span><br><span class="line">- 他是1970年5月20日在北京出生的。（时间在前）</span><br></pre></td></tr></table></figure></li><li><p>英语中时间状语、地点状语的排列一般是从小到大，而汉语中则是从大到小。其次我们谈谈句序的调整。这里，句序是指复合句中主句和从句的时间和逻辑关系叙述的顺序。</p></li></ul><h2 id="时间顺序的调整。"><a href="#时间顺序的调整。" class="headerlink" title="时间顺序的调整。"></a>时间顺序的调整。</h2><ul><li>英语复合句中，表示时间的从句可以放在主句之前，也可以放在主句之后，汉语中则通常先叙述先发生的事，后叙述后发生的事。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">I went out for a walk after I had my dinner．（从句在主句之后）</span><br><span class="line"></span><br><span class="line">我吃了晚饭后出去散步。（从句在主句之前）</span><br></pre></td></tr></table></figure><ul><li>英语复合句中有时包含两个以上的时间从句，各个时间从句的次序比较灵活，汉语则一般按事情发生的先后安排其位置。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">He had flown yesterday from Beijing where he spent his vocation after finishing the </span><br><span class="line">meeting he had taken part in Tianjin．</span><br><span class="line"></span><br><span class="line">他本来在天津开会，会议一结束，他就去北京度假了，昨天才坐飞机回来。</span><br></pre></td></tr></table></figure><h2 id="英汉语复合句中的逻辑顺序的调整。"><a href="#英汉语复合句中的逻辑顺序的调整。" class="headerlink" title="英汉语复合句中的逻辑顺序的调整。"></a>英汉语复合句中的逻辑顺序的调整。</h2><ul><li><p>表示因果关系的英语复合句中，因果顺序灵活，在汉语中多数情况是原因在前，结果在后。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">He had to stay in bed because he was ill．（后置）</span><br><span class="line"></span><br><span class="line">因为他病了，他只好呆在床上。（前置）</span><br></pre></td></tr></table></figure></li><li><p>表示条件（假设）与结果关系的英语复合句中，条件（假设）与结果的顺序也不固定，在汉语中则是条件在前，结果在后。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">I still hope you will come back if arrangements could be made．（后置）</span><br><span class="line"></span><br><span class="line">如果安排得好，我还是希望你来。（前置）</span><br></pre></td></tr></table></figure></li><li><p>表示目的与行动关系的英语复合句中，目的与行动的顺序比较固定，多数是行动在前，目的在后，汉语也如此，但有时为了强调，也可把目的放在行动之前。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Better take your umbrella in case it rains．（后置）</span><br><span class="line"></span><br><span class="line">最好带上伞以防下雨。（前置）</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
      <category term="digest" scheme="https://hackettyu.com/categories/digest/"/>
    
    
      <category term="english" scheme="https://hackettyu.com/tags/english/"/>
    
  </entry>
  
  <entry>
    <title>文档体系</title>
    <link href="https://hackettyu.com/180920/"/>
    <id>https://hackettyu.com/180920/</id>
    <published>2018-09-20T04:00:00.000Z</published>
    <updated>2018-10-16T07:54:14.973Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://github.com/ruanyf/document-style-guide/blob/master/docs/structure.md" target="_blank" rel="noopener">https://github.com/ruanyf/document-style-guide/blob/master/docs/structure.md</a></p></blockquote><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>软件手册是一部完整的书，建议采用下面的结构。</p><ul><li><strong>简介</strong>（Introduction）： [必备] [文件] 提供对产品和文档本身的总体的、扼要的说明</li><li><strong>快速上手</strong>（Getting Started）：[可选] [文件] 如何最快速地使用产品</li><li><strong>入门篇</strong>（Basics）： [必备] [目录] 又称”使用篇“，提供初级的使用教程<ul><li><strong>环境准备</strong>（Prerequisite）：[必备] [文件] 软件使用需要满足的前置条件</li><li><strong>安装</strong>（Installation）：[可选] [文件] 软件的安装方法</li><li><strong>设置</strong>（Configuration）：[必备] [文件] 软件的设置</li></ul></li><li><strong>进阶篇</strong>（Advanced)：[可选] [目录] 又称”开发篇“，提供中高级的开发教程</li><li><strong>API</strong>（Reference）：[可选] [目录|文件] 软件 API 的逐一介绍</li><li><strong>FAQ</strong>：[可选] [文件] 常见问题解答</li><li><strong>附录</strong>（Appendix）：[可选] [目录] 不属于教程本身、但对阅读教程有帮助的内容<ul><li><strong>Glossary</strong>：[可选] [文件] 名词解释</li><li><strong>Recipes</strong>：[可选] [文件] 最佳实践</li><li><strong>Troubleshooting</strong>：[可选] [文件] 故障处理</li><li><strong>ChangeLog</strong>：[可选] [文件] 版本说明</li><li><strong>Feedback</strong>：[可选] [文件] 反馈方式</li></ul></li></ul><p>下面是两个真实范例，可参考。</p><ul><li><a href="http://redux.js.org/index.html" target="_blank" rel="noopener">Redux 手册</a></li><li><a href="http://flight-manual.atom.io/" target="_blank" rel="noopener">Atom 手册</a></li></ul><h2 id="文件名"><a href="#文件名" class="headerlink" title="文件名"></a>文件名</h2><p>文档的文件名不得含有空格。</p><p>文件名必须使用半角字符，不得使用全角字符。这也意味着，中文不能用于文件名。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">错误： 名词解释.md</span><br><span class="line"></span><br><span class="line">正确： glossary.md</span><br></pre></td></tr></table></figure><p>文件名建议只使用小写字母，不使用大写字母。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">错误：TroubleShooting.md</span><br><span class="line"></span><br><span class="line">正确：troubleshooting.md</span><br></pre></td></tr></table></figure><p>为了醒目，某些说明文件的文件名，可以使用大写字母，比如<code>README</code>、<code>LICENSE</code>。</p><p>文件名包含多个单词时，单词之间建议使用半角的连词线（<code>-</code>）分隔。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">不佳：advanced_usage.md</span><br><span class="line"></span><br><span class="line">正确：advanced-usage.md</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        
        
          
        
      
    
    </summary>
    
      <category term="digest" scheme="https://hackettyu.com/categories/digest/"/>
    
    
      <category term="others" scheme="https://hackettyu.com/tags/others/"/>
    
  </entry>
  
</feed>
