<!DOCTYPE html><html class="theme-next muse use-motion" lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="theme-color" content="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4"><link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222"><meta name="keywords" content="hackettyu"><link rel="alternate" href="/atom.xml" title="HackettYu's blog" type="application/atom+xml"><meta name="description" content="hackettyu"><meta name="keywords" content="hackettyu"><meta property="og:type" content="website"><meta property="og:title" content="HackettYu&#39;s blog"><meta property="og:url" content="https://hackettyu.com/page/6/index.html"><meta property="og:site_name" content="HackettYu&#39;s blog"><meta property="og:description" content="hackettyu"><meta property="og:locale" content="zh-Hans"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="HackettYu&#39;s blog"><meta name="twitter:description" content="hackettyu"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Muse",version:"5.1.4",sidebar:{position:"left",display:"post",offset:12,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!0,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="https://hackettyu.com/page/6/"><title>HackettYu's blog - hackettyu</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-home"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">HackettYu's blog</span><span class="logo-line-after"><i></i></span></a></div><h1 class="site-subtitle" itemprop="description">hackettyu</h1></div><div class="site-nav-toggle"> <button><span class="btn-bar"></span><span class="btn-bar"></span><span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br> 首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br> 关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br> 标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br> 分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br> 归档</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br> 搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i></span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"> <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><section id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://hackettyu.com/180927_3/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="HackettYu"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="HackettYu's blog"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> <a class="post-title-link" href="/180927_3/" itemprop="url">JSR 133 FAQ 翻译</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-27T18:00:00+08:00">2018-09-27</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/digest/" itemprop="url" rel="index"><span itemprop="name">digest</span></a></span></span> <span id="/180927_3/" class="leancloud_visitors" data-flag-title="JSR 133 FAQ 翻译"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span> <span class="post-meta-item-text">阅读次数&#58;</span><span class="leancloud-visitors-count"></span></span></div></header><div class="post-body" itemprop="articleBody"><blockquote><p><a href="https://xurongyang.github.io/2017/05/20/JSR-133-FAQ%E7%BF%BB%E8%AF%91/" target="_blank" rel="noopener">https://xurongyang.github.io/2017/05/20/JSR-133-FAQ%E7%BF%BB%E8%AF%91/</a><br><a href="https://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html" target="_blank" rel="noopener">https://www.cs.umd.edu/~pugh/java/memoryModel/jsr-133-faq.html</a></p></blockquote><h2 id="内存模型到底是什么"><a href="#内存模型到底是什么" class="headerlink" title="内存模型到底是什么"></a>内存模型到底是什么</h2><p>在多处理器计算机系统中，处理器一般拥有多层次的内存缓存，内存缓存一方面能够提高访问数据的速度（因为数据离处理器更近了），另一方面能降低总线的流量（因为许多内存操作可以被缓存替代）。内存缓存能极大的提高性能，但是也带来了一些挑战。例如，当两个处理器同时访问同一个内存地址时会发生什么事情？在什么情况下他们能看到相同的值？</p><p>在处理器级别，存储器模型定义了必要和充分的条件，用于知道其他处理器对存储器的写入对于当前处理器是可见的，并且当前处理器的写入对于其他处理器是可见的。一些处理器应用了强一致内存模型，所有的处理器对于同一个内存地址，看到的值都是一样的。其它一些处理器应用了弱一些的内存模型，利用内存屏障来刷新处理器本地缓存，这样处理器就能看到其它处理器的写操作的结果。这些内存屏障通常在lock和unlock操作时执行，它们对于高级程序设计语言是透明的。</p><p>在强一致内存模型下编写程序通常更为容易，因为不需要用到内存屏障。然而，即使是一致性最强的内存模型也经常会用到内存屏障。往往他们的位置都是违反直觉的。处理器设计的最新趋势鼓励了较弱的内存模型，因为它们对缓存一致性的放宽使得可以在多个处理器和更大量的内存中实现更大的可扩展性。</p><p>一个写入操作什么时间对另外一个线程可见的问题部分是由编译器重排序导致的。例如，编译器可能会决定把一个写入操作推迟执行会更加高效。只有不改变程序的语义即可。如果编译器推迟了一个操作，另一个线程直到它真正执行后才会看到操作结果，这反应了缓存的效果（最后半句有点奇怪）。</p><p>此外，写操作也可能会提前，在这种情况下，其它线程可能会提前看到一个写操作发生。所有这些都是特意设计的 - 通过给编译器，运行时或硬件提供灵活性，以最佳顺序在内存模型的范围内执行操作，我们可以实现更高的性能。</p><p>举一个简单的例子：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Class Reordering &#123;</span><br><span class="line">  int x = 0, y = 0;</span><br><span class="line">  public void writer() &#123;</span><br><span class="line">    x = 1;</span><br><span class="line">    y = 2;</span><br><span class="line">  &#125;</span><br><span class="line">  public void reader() &#123;</span><br><span class="line">    int r1 = y;</span><br><span class="line">    int r2 = x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>假设这段代码被两个线程并发执行，并且y读取到的值是2。因为y的写入在x之后，所以程序员可能会认为x的值必定是1。然而，写操作可能被重排序了，如果发生这种情况，可能会先写入y，然后发生两个变量的读取，最后写入x。 结果是r1的值为2，但r2的值为0。</p><p>Java内存模型描述了多线程代码中的哪些行为是合法的，以及线程如何通过内存进行交互。 它描述了程序中变量之间的关系以及在实际计算机系统中存储和检索内存或寄存器的底层细节。 它可以使用各种各样的硬件和各种编译器优化来正确实现。</p><p>Java包括几种语言结构，包括volatile，final和synchronized，它们旨在帮助程序员将程序的并发要求提供给编译器。 Java内存模型定义了volatile和synchronized的行为，更重要的是确保正确同步的Java程序在所有处理器架构上正确运行。</p><p>其它语言有没有内存模型<br>大多数其他编程语言（如C和C ++）并没有直接支持多线程。 这些语言抑制编译器和体系结构中的重排序提供给程序员的保护在很大程度上取决于所使用的线程库（例如pthreads），使用的编译器以及运行代码的平台提供的保证。</p><h2 id="JSR-133讲了什么内容"><a href="#JSR-133讲了什么内容" class="headerlink" title="JSR 133讲了什么内容"></a>JSR 133讲了什么内容</h2><p>自1997年以来，在Java语言规范第17章定义的Java Memory Model中发现了几个严重的缺陷。 这些缺陷允许混淆行为（例如观察到final改变了其值），并且破坏了编译器执行常见优化的能力。</p><p>Java内存模型是一项雄心勃勃的工作; 这是第一次编程语言规范试图并入一个内存模型，可以为各种架构的并发提供一致的语义。 不幸的是，定义一个一致和直观的记忆模型比预期的困难得多。 JSR 133定义了一种用于Java语言的新内存模型，它修复了较早内存模型的缺陷。 为了做到这一点，final和volatile的语义需要改变。</p><p>完整内容可以在 <a href="http://www.cs.umd.edu/users/pugh/java/memoryModel" target="_blank" rel="noopener">The Java Memory Model</a> 找到，but the formal semantics are not for the timid（这句不懂）.It is surprising, and sobering, to discover how complicated seemingly simple concepts like synchronization really are（这句也是）.幸运的是，你不需要了解正式语义的细节 - JSR 133的目标是创建一套语义，为volatile，synchronized和final提供了一个直观的框架。</p><h2 id="JSR-133的目标包括："><a href="#JSR-133的目标包括：" class="headerlink" title="JSR 133的目标包括："></a>JSR 133的目标包括：</h2><ul><li>保持现有的安全保障，如类型安全，加强其他。 例如，变量值可能不会被创建为某个没有赋值给它的值：由某个线程观察到的变量的每个值必须是由某个线程设置过的值。</li><li>正确同步程序的语义应尽可能简单直观。</li><li>应该定义不完整或不正确同步的程序的语义，以使潜在的安全隐患最小化。（不懂）</li><li>程序员应该能够自信地说明多线程程序如何与内存交互。</li><li>应该可以在广泛的流行硬件架构中设计正确的，高性能的JVM实现。</li><li>应提供初始化安全的新保证。 如果对象被正确构造（这意味着在构造过程中它的引用不会逸出），那么可以看到对该对象的引用的所有线程也将看到在构造函数中设置的final域的值，而不需要同步。</li><li>对已存在的代码有很小的影响</li></ul><h2 id="重排序的含义是什么？"><a href="#重排序的含义是什么？" class="headerlink" title="重排序的含义是什么？"></a>重排序的含义是什么？</h2><p>有许多情况下，程序变量（对象实例字段，类静态字段和数组元素）的访问可能会以与程序指定的不同的顺序执行。 编译器可以按照优化的名义，对指令进行重排序。 数据可以在寄存器，处理器高速缓存和主存储器之间以与程序指定的顺序不同的顺序移动。</p><p>例如，如果线程先写入字段a，然后写入字段b，并且b的值不依赖于a的值，则编译器可以自由地对这些操作进行重新排序，并且缓存可以自由地刷新b的值到内存，在a之前。 有一些潜在的重新排序来源，如编译器，JIT和缓存。</p><p>编译器，运行时和硬件会创造一个as-if-serial语义的错觉，这意味着在一个单线程程序中，该程序不应该能够观察到重排序的影响。 然而，重排序可能会在不正确同步的多线程程序中发挥作用，其中一个线程能够观察到其他线程的影响，并且可能能够检测到该变量访问以与代码顺序不同的方式显示给其他线程。</p><p>大多数时候，一个线程不在乎其它线程在做什么。 但是，如果它在乎，就需要用到同步。</p><h2 id="旧内存模型有什么问题？"><a href="#旧内存模型有什么问题？" class="headerlink" title="旧内存模型有什么问题？"></a>旧内存模型有什么问题？</h2><p>旧的内存模型有几个严重的问题。它很难理解，因此被广泛的违背。例如，旧的内存模型在很多情况下都没有允许在大多数JVM中应用的重排序措施。这带来了JSR 133的形成。</p><p>例如，一个广泛认同的观点是，如果使用final，则线程之间的同步是不必要的，以保证另一个线程将看到该字段的值。 虽然这是一个合理的假设和一个明智的行为，实际上我们想要的东西如何工作，在旧的记忆模式下，根本不是这么做的。 旧的内存模型中没有任何内容表明它处理final字段与任何其他字段不同 - 意思是同步是确保所有线程都看到由构造函数编写的最终字段的值的唯一方法。 因此，线程可能会看到该字段的默认值，然后在稍后的时间内看到其构造的值。 这意味着，例如，像String这样的不可变对象似乎可以改变它们的值 - 这是一个令人不安的现象。</p><p>旧的内存模型允许volatile与非volatile的读写操作进行重排序，这与大多数开发人员对volatile的直觉不一致，从而导致混乱。</p><p>最后，正如我们将看到的那样，程序员对程序错误同步时可能会发生什么的直觉通常是错误的。 JSR-133的目标之一是提请注意到这一事实。</p><h2 id="“非正确同步”是什么意思？"><a href="#“非正确同步”是什么意思？" class="headerlink" title="“非正确同步”是什么意思？"></a>“非正确同步”是什么意思？</h2><p>不正确同步的代码对于不同人的含义不一样。 当我们谈到在Java内存模型的上下文中错误地同步的代码时，我们的意思是任何代码</p><p>有一个线程写入一个变量<br>有另一个线程读取相同的变量<br>写入和读取没有用同步操作来排序<br>当这些规则被违反时，我们说我们在这个变量上有一个数据竞争。 具有数据竞争的程序是一个不正确同步的程序。</p><h2 id="Synchronization同步操作做了什么"><a href="#Synchronization同步操作做了什么" class="headerlink" title="Synchronization同步操作做了什么"></a>Synchronization同步操作做了什么</h2><p>同步有几个方面。 最容易理解的是互斥 - 只有一个线程可以拿到一个监视器锁，因此在监视器锁上同步意味着一旦一个线程进入被监视器锁保护的同步块，则没有其他线程可以进入该监视器锁保护的块，直到第一个线程退出同步块。</p><p>但是不仅仅是互斥访问，Synchronization同步确保在同步块之前或期间，线程的内存写入以可预测的方式显示给同一监视器上同步的其他线程。 在我们退出同步程序段后，我们释放监视器锁，该监视器锁具有将缓存刷新到内存的作用，使得此线程所做的写入对其他线程可见。 在我们可以进入同步块之前，我们需要获取监视器锁，该监视器锁具有使本地处理器缓存无效的效果，以便从内存重新加载变量。 然后，我们将能够看到所有的上一版本都可以看到的写入。</p><p>在缓存方面进行讨论，可能听起来好像这些问题只影响多处理器机器。 然而，可以在单个处理器上轻松看到重新排序的效果。 例如，编译器不会将acquire之后的代码移动到它之前，也不会把release之前的代码移动到它之后。当我们说acquire和release对缓存的操作时，我们忽略了很多的细节内容。</p><p>新的内存模型语义在内存操作（读取字段，写入字段，加锁，解锁）和其他线程操作（启动和连接）上创建了一些偏序规则，其中一些操作在其他操作之前发生。 当一个动作发生在另一个动作之前，第一个被保证在第二个之前被执行并且结果对其可见。 此排序的规则如下：</p><ul><li>单线程中是完全按照代码顺序执行的</li><li>监视器的解锁操作发生在该监视器随后的加锁操作之前</li><li>对volatile字段的写入发生在该volatile字段每次后续读取之前</li><li>线程的start操作发生于该线程内的任何一行代码之前</li><li>一个线程内的所有操作都发生在join了这个线程的线程之前<br>这意味着一个线程在退出同步块之前的所有内存操作对于任何其它进入该同步块的线程都是可见的，因为所有的内存操作都发生在release之前，release发生在acquire之前。</li></ul><p>另外一个含义是，下面的这个被许多人用作内存屏障的操作不起作用：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">synchronized (new Object()) &#123;&#125;</span><br></pre></td></tr></table></figure><p></p><p>这实际上没有任何效果，你的编译器可以完全删除它，因为编译器知道没有其他线程将在同一个监视器上同步。如果一个线程想看到另外一个线程的结果，就必须设置一个happens before规则。</p><p>重要提示：两个线程必须在同一个监视器锁上进行同步，这样才能设置happens before规则。如果线程A在X上同步，线程B在Y上同步，这样是没有效果的。release和acquire必须匹配，否则会存在数据竞争的问题。</p><h2 id="不可见变量如何看起来修改了它的值"><a href="#不可见变量如何看起来修改了它的值" class="headerlink" title="不可见变量如何看起来修改了它的值"></a>不可见变量如何看起来修改了它的值</h2><p>最好的例子是String类的一个实现。</p><p>字符串可以实现为具有三个字段的对象 - 字符数组，该数组中的偏移量和长度。 以这种方式实现String的理由，而不是仅使用字符数组，它允许多个String和StringBuffer对象共享相同的字符数组，并避免额外的对象分配和复制。 所以，例如，String.substring（）方法可以通过创建一个新的字符串来实现，该字符串与原始的String共享相同的字符数组，并且在长度和偏移量字段中只是不同。 对于字符串，这些字段都是final字段。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s1 = &quot;/usr/tmp&quot;;</span><br><span class="line">String s2 = s1.substring(4);</span><br></pre></td></tr></table></figure><p></p><p>字符串s2的偏移量为4，长度为4.但是，在旧内存模型下，另一个线程可以将偏移量看作默认值为0，然后看到正确的值为4， 它将显示为字符串“/usr”更改为“/tmp”。</p><p>旧内存模型允许这种行为，几个JVM禁止了这些行为，在新的内存模型下，这种行为是违法的。</p><h2 id="新的内存模型下final域的工作原理是怎样的？"><a href="#新的内存模型下final域的工作原理是怎样的？" class="headerlink" title="新的内存模型下final域的工作原理是怎样的？"></a>新的内存模型下final域的工作原理是怎样的？</h2><p>对象的final字段的值在其构造函数中设置。假设对象被正确构造，一旦构造完成，在构造函数中分配的final字段的值将对所有其他线程都是可见的，不需要同步。 此外，final字段引用的任何其他对象或数组的值将与final字段保持同步更新。</p><p>对象被正确构造是什么意思？ 这仅仅意味着在构造过程中，不允许正在构造的对象的引用“逃脱”。 （参见安全构造技术的例子）换句话说，不要对正在构造的对象引用另外一个线程可能看到的对象; 不要将其分配给静态字段，不要将其注册为与任何其他对象的监听器，等等。 这些任务应该在构造函数完成之后完成，而不是在构造函数中完成。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class FinalFieldExample &#123;</span><br><span class="line">  final int x;</span><br><span class="line">  int y;</span><br><span class="line">  static FinalFieldExample f;</span><br><span class="line">  public FinalFieldExample() &#123;</span><br><span class="line">    x = 3;</span><br><span class="line">    y = 4;</span><br><span class="line">  &#125;</span><br><span class="line">  static void writer() &#123;</span><br><span class="line">    f = new FinalFieldExample();</span><br><span class="line">  &#125;</span><br><span class="line">  static void reader() &#123;</span><br><span class="line">    if (f != null) &#123;</span><br><span class="line">      int i = f.x;</span><br><span class="line">      int j = f.y;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上面的类是一个使用final字段的例子。 线程执行reader保证为f.x看到值3，因为它是final的。不能保证为y看到值4，因为它不是final的。 如果FinalFieldExample的构造函数如下所示：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public FinalFieldExample() &#123; // bad!</span><br><span class="line">  x = 3;</span><br><span class="line">  y = 4;</span><br><span class="line">  // bad construction - allowing this to escape</span><br><span class="line">  global.obj = this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>那么从<code>global.obj</code>读取this的线程不能保证为x看到3。</p><p>能看到正确构造的字段值的能力是很好的，但是如果字段本身是引用，那么你还希望你的代码可以看到它指向的对象（或数组）的最新值。 如果你的领域是一个final域，这也是保证的。 所以，你可以有一个final指向数组的指针，而不用担心其他线程看到数组的引用是正确的，但数组的内容不正确。Again, by “correct” here, we mean “up to date as of the end of the object’s constructor”, not “the latest value available”.</p><p>现在，说完所有这一切，如果在一个线程构造一个不可变对象（即只包含final字段的对象）之后，你想要确保所有其他线程都能看到正确的值，你通常还需要使用同步。 没有其他方法来确保，例如，第二个线程将会看到对不可变对象的引用。程序从final字段获得的保证应该非常小心，深入细心地了解如何在代码中管理并发性。</p><p>用JNI修改final字段的值，这样的行为没有具体定义。</p><h2 id="volatile做了什么"><a href="#volatile做了什么" class="headerlink" title="volatile做了什么"></a>volatile做了什么</h2><p>volatile字段是用于在线程之间通信状态的特殊字段。每个读取的volatile的线程都会看到最后写入volatile的值; 实际上，它们被程序员设计为不会因为缓存或者重排序看不到最新的值的字段。禁止编译器和运行时环境在寄存器中分配volatile变量。 他们还必须确保在写入之后，将它们从缓存中刷新到内存，以便它们可以立即变得对其他线程可见。 类似地，在读取volatile字段之前，缓存必须被设置为无效，使得内存（而不是本地处理器高速缓存）中的值是最新的值。对volatile变量的访问重新排序也有其他限制。</p><p>在旧的内存模型下，volatile变量之间是不可以重排序的，但是和普通变量之间是可以重排序的，这破坏了volatile对于线程间传递信号的有用性。</p><p>在新的内存模型下，volatile变量之间还是不可以重排序，但是和普通变量之间也不可以重排序了。写入volatile的值和释放synchronized锁的内存效果是一样的，读取volatile的值和synchronized加锁的内存效果是一样的。实际上，因为新的存储器模型对于其他字段和volatile字段的重排序进行了更加严格的约束，无论是不是volatile变量，线程A在写入volatile字段f时可见的任何东西对于线程B在读取f时都是可见的。</p><p>下面是使用volatile的一个例子：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class VolatileExample &#123;</span><br><span class="line">  int x = 0;</span><br><span class="line">  volatile boolean v = false;</span><br><span class="line">  public void writer() &#123;</span><br><span class="line">    x = 42;</span><br><span class="line">    v = true;</span><br><span class="line">  &#125;</span><br><span class="line">  public void reader() &#123;</span><br><span class="line">    if (v == true) &#123;</span><br><span class="line">      //uses x - guaranteed to see 42.</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>假设一个线程正在调用writer，另一个线程是调用reader。 对v的写入器会把x的值写入到内存，并且v从内存中获取该值。 因此，如果读者看到v的值为true，那么也可以保证看到之前发生的写入42。 在旧的记忆模型下不是这样。 如果v不是volatile的，那么编译器可以对写入器中的写入进行重新排序，读者对x的读取可能会看到0。</p><p>volatile的语义被大大加强，几乎到达了synchronized的水平。对于可见性来说，volatile操作几乎和synchronized一样。</p><p>重要提示：和synchronized一样，必须用同一个volatile才能保证可见性。</p><p>新的内存模型是否修复了“双重锁定”问题？<br>（臭名昭着的）双重检查锁定成语（也称为多线程单例模式）是一种技巧，旨在支持延迟初始化，同时避免同步的开销。在非常早期的JVM中，同步非常缓慢，开发人员急于删除它 - 也许太渴望了。双重锁定的模式如下所示：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// double-checked-locking - don&apos;t do this!</span><br><span class="line">private static Something instance = null;</span><br><span class="line">public Something getInstance() &#123;</span><br><span class="line">  if (instance == null) &#123;</span><br><span class="line">    synchronized (this) &#123;</span><br><span class="line">      if (instance == null)</span><br><span class="line">        instance = new Something();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这看起来很聪明 - 在公共代码路径上避免了同步。 它只有一个问题 - 它没有作用。为什么没有作用？最明显的原因是初始化实例和对实例字段的写入可以由编译器或缓存重新排序，这将具有返回看起来是部分构造的对象的效果。 结果将是我们读取一个未初始化的对象。 还有很多其他原因能说明为什么这是错误的。没有办法使用旧的Java内存模型进行修复。更多信息可以查看：Double-checked locking: Clever, but broken和The “Double Checked Locking is broken” declaration</p><p>许多人认为使用volatile关键字会消除在尝试使用双重检查锁定模式时出现的问题。 在1.5之前的JVM中，volatile不会确保它有效。 在新的内存模型下，使实例字段volatile将“修复”双重锁定的问题，因为在构造和读取之间存在happens before关系。</p><p>用另外一种方式更好：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private static class LazySomethingHolder &#123;</span><br><span class="line">  public static Something something = new Something();</span><br><span class="line">&#125;</span><br><span class="line">public static Something getInstance() &#123;</span><br><span class="line">  return LazySomethingHolder.something;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>由于静态字段的初始化保证，该代码保证是正确的; 如果在静态初始化程序中设置了一个字段，那么它将被保证被正确地显示给访问该类的任何线程。</p><p>对虚拟机从业者<br>你应该看 <a href="http://gee.cs.oswego.edu/dl/jmm/cookbook.html" target="_blank" rel="noopener">The JSR-133 Cookbook for Compiler Writers</a></p><h2 id="为什么要关心内存模型？"><a href="#为什么要关心内存模型？" class="headerlink" title="为什么要关心内存模型？"></a>为什么要关心内存模型？</h2><p>你为什么要关心？ 并发错误很难调试。他们经常不出现在测试中，需要等待，直到你的程序在高负载下运行，并且难以重现。 你最好提前花费额外的努力，以确保您的程序正确同步; 虽然这不容易，但比尝试调试严重同步的应用程序要容易得多。</p><div></div></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://hackettyu.com/180927_2/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="HackettYu"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="HackettYu's blog"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> <a class="post-title-link" href="/180927_2/" itemprop="url">synchronized 实现</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-27T16:00:00+08:00">2018-09-27</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/digest/" itemprop="url" rel="index"><span itemprop="name">digest</span></a></span></span> <span id="/180927_2/" class="leancloud_visitors" data-flag-title="synchronized 实现"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span> <span class="post-meta-item-text">阅读次数&#58;</span><span class="leancloud-visitors-count"></span></span></div></header><div class="post-body" itemprop="articleBody"><blockquote><p><a href="https://xurongyang.github.io/" target="_blank" rel="noopener">https://xurongyang.github.io/</a></p></blockquote><h2 id="synchronized-用法"><a href="#synchronized-用法" class="headerlink" title="synchronized 用法"></a>synchronized 用法</h2><p>synchronized是Java语言中用于线程间并发互斥访问的关键字，通常有两种用法。</p><h2 id="synchronized-修饰对象"><a href="#synchronized-修饰对象" class="headerlink" title="synchronized 修饰对象"></a>synchronized 修饰对象</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public void method() &#123;</span><br><span class="line">  synchronized (someObject) &#123;</span><br><span class="line">    // code</span><br><span class="line">  &#125;</span><br><span class="line">  // no effect</span><br><span class="line">  synchronized (new Object()) &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当synchronized修饰的是对象时，实际上对synchronized块的代码加了一个对象锁，只有获取到这个锁才能执行synchronized块的代码，达到了互斥访问的效果。</p><p>倘若synchronized修饰的是new Object()呢？因为每次执行到此处时都会对这个新创建出来的对象加锁，而每次加锁的对象又都不相同，所以没有办法达到互斥访问的目的。</p><h2 id="synchronized-修饰方法"><a href="#synchronized-修饰方法" class="headerlink" title="synchronized 修饰方法"></a>synchronized 修饰方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public synchronized method1() &#123;&#125;</span><br><span class="line">public static synchronized method2() &#123;&#125;</span><br></pre></td></tr></table></figure><p>synchronized修饰方法需要区分修饰的是实例方法还是类方法，倘若修饰的是实例方法的话，那么synchronized加锁的对象就是对应的类实例，倘若修饰的是类方法的话，那么synchronized加锁的对象就是该类的Class对象。</p><p>synchronized的字节码表示<br>synchronized作为一个关键字在代码层面就是这样了，下面我们分析下它在字节码层面的表示。先看一段代码：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class SyncCodeBlock &#123;</span><br><span class="line">   public int i;</span><br><span class="line">   public void syncTask()&#123;</span><br><span class="line">       //同步代码库</span><br><span class="line">       synchronized (this)&#123;</span><br><span class="line">           i++;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>通过javap反编译，得到的字节码如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Compiled from &quot;SyncCodeBlock.java&quot;</span><br><span class="line">public class SyncCodeBlock &#123;</span><br><span class="line">  public int i;</span><br><span class="line">  public SyncCodeBlock();</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0       </span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       4: return        </span><br><span class="line">  public void syncTask();</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0       </span><br><span class="line">       1: dup           </span><br><span class="line">       2: astore_1      </span><br><span class="line">       3: monitorenter  </span><br><span class="line">       4: aload_0       </span><br><span class="line">       5: dup           </span><br><span class="line">       6: getfield      #2                  // Field i:I</span><br><span class="line">       9: iconst_1      </span><br><span class="line">      10: iadd          </span><br><span class="line">      11: putfield      #2                  // Field i:I</span><br><span class="line">      14: aload_1       </span><br><span class="line">      15: monitorexit   </span><br><span class="line">      16: goto          24</span><br><span class="line">      19: astore_2      </span><br><span class="line">      20: aload_1       </span><br><span class="line">      21: monitorexit   </span><br><span class="line">      22: aload_2       </span><br><span class="line">      23: athrow        </span><br><span class="line">      24: return        </span><br><span class="line">    Exception table:</span><br><span class="line">       from    to  target type</span><br><span class="line">           4    16    19   any</span><br><span class="line">          19    22    19   any</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>对上面的代码做个简化，去掉与synchronized没关系的逻辑，简化版如下 ：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">3: monitorenter  //进入同步方法</span><br><span class="line">//..........省略其他  </span><br><span class="line">15: monitorexit   //退出同步方法</span><br><span class="line">16: goto          24</span><br><span class="line">//省略其他.......</span><br><span class="line">21: monitorexit //退出同步方法</span><br></pre></td></tr></table></figure><p></p><p>当执行monitorenter指令时，会尝试获取对象的锁，如果该对象锁在执行前没有被锁定或者当前线程已经拥有了该对象的锁，就把锁的计数器加一。相应的，在执行monitorexit指令时会将锁计数器减一，当锁计数器值为0时，锁就被释放。如果获取锁失败，该线程就要阻塞等待，知道对象锁被另外一个线程释放。</p><p>值得注意的是编译器将会确保无论方法通过何种方式完成，方法中调用过的每条 monitorenter 指令都有执行其对应 monitorexit 指令，而无论这个方法是正常结束还是异常结束。为了保证在方法异常完成时 monitorenter 和 monitorexit 指令依然可以正确配对执行，编译器会自动产生一个异常处理器，这个异常处理器声明可处理所有的异常，它的目的就是用来执行 monitorexit 指令。从字节码中也可以看出多了一个monitorexit指令，它就是异常结束时被执行的释放monitor 的指令。</p><p>对于synchronized修饰的是方法的情况，在反编译的字节码中并没有monitorenter和monitorexit指令，字节码中的方法申明和代码中保持一致，例如：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static synchronized void syncTask();</span><br><span class="line">  Code:</span><br><span class="line">     0: getstatic     #2                  // Field i:I</span><br><span class="line">     3: iconst_1      </span><br><span class="line">     4: iadd          </span><br><span class="line">     5: putstatic     #2                  // Field i:I</span><br><span class="line">     8: return</span><br></pre></td></tr></table></figure><p></p><p>其实无论字节码中是monitorenter也好，还是monitorexit也好，都只是告知虚拟机进行锁操作的标志。</p><h2 id="synchronized锁优化"><a href="#synchronized锁优化" class="headerlink" title="synchronized锁优化"></a>synchronized锁优化</h2><h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><p>在 HotSpot 虚拟机中，对象在内存中存储布局分为 3 块区域：对象头（Header）、实例数据（Instance Data）、对齐填充。<br><img src="https://xurongyang.github.io/images/java-object.png" alt="image"></p><p>HotSpot 虚拟机的对象头包括两部分（非数组对象）信息，如下图所示：<br><img src="https://xurongyang.github.io/images/java-object-header.png" alt="images"></p><ul><li>第一部分用于存储对象自身的运行时数据，如哈希码（HashCode）、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳、对象分代年龄，这部分信息称为“Mark Word”；Mark Word 被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，它会根据自己的状态复用自己的存储空间。</li><li>第二部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例；</li><li>如果对象是一个 Java 数组，那在对象头中还必须有一块用于记录数组长度的数据。因为虚拟机可以通过普通 Java 对象的元数据信息确定 Java 对象的大小，但是从数组的元数据中无法确定数组的大小。<br>这部分数据的长度在 32 位和 64 位的虚拟机（未开启压缩指针）中分别为 32bit 和 64bit。</li></ul><p>在 32 位系统下，存放 Class 指针的空间大小是 4 字节，Mark Word 空间大小也是4字节，因此头部就是 8 字节，如果是数组就需要再加 4 字节表示数组的长度，如下表所示：</p><p><img src="https://xurongyang.github.io/images/java-object-header-size.png" alt="java-object-header-size"></p><h3 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h3><p>实例数据部分是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。</p><p>这部分的存储顺序会受到虚拟机分配策略参数（FieldsAllocationStyle）和字段在 Java 源码中定义顺序的影响。</p><h3 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h3><p>对齐填充不是必然存在的，没有特别的含义，它仅起到占位符的作用。</p><p>由于 HotSpot VM 的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，也就是说对象的大小必须是 8 字节的整数倍。对象头部分是 8 字节的倍数，所以当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>偏向锁是Java 6之后加入的新锁，它是一种针对加锁操作的优化手段，经过研究发现，在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，因此为了减少同一线程获取锁(会涉及到一些CAS操作,耗时)的代价而引入偏向锁。偏向锁的核心思想是，如果一个线程获得了锁，那么锁就进入偏向模式，此时Mark Word 的结构也变为偏向锁结构，当这个线程再次请求锁时，无需再做任何同步操作，即获取锁的过程，这样就省去了大量有关锁申请的操作，从而也就提供程序的性能。所以，对于没有锁竞争的场合，偏向锁有很好的优化效果，毕竟极有可能连续多次是同一个线程申请相同的锁。但是对于锁竞争比较激烈的场合，偏向锁就失效了，因为这样场合极有可能每次申请锁的线程都是不相同的，因此这种场合下不应该使用偏向锁，否则会得不偿失，需要注意的是，偏向锁失败后，并不会立即膨胀为重量级锁，而是先升级为轻量级锁。下面我们接着了解轻量级锁。</p><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>倘若偏向锁失败，虚拟机并不会立即升级为重量级锁，它还会尝试使用一种称为轻量级锁的优化手段(1.6之后加入的)，此时Mark Word 的结构也变为轻量级锁的结构。轻量级锁能够提升程序性能的依据是“对绝大部分的锁，在整个同步周期内都不存在竞争”，注意这是经验数据。需要了解的是，轻量级锁所适应的场景是线程交替执行同步块的场合，如果存在同一时间访问同一锁的场合，就会导致轻量级锁膨胀为重量级锁。</p><h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。这是基于在大多数情况下，线程持有锁的时间都不会太长，如果直接挂起操作系统层面的线程可能会得不偿失，毕竟操作系统实现线程之间的切换时需要从用户态转换到核心态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，因此自旋锁会假设在不久将来，当前的线程可以获得锁，因此虚拟机会让当前想要获取锁的线程做几个空循环(这也是称为自旋的原因)，一般不会太久，可能是50个循环或100循环，在经过若干次循环后，如果得到锁，就顺利进入临界区。如果还不能获得锁，那就会将线程在操作系统层面挂起，这就是自旋锁的优化方式，这种方式确实也是可以提升效率的。最后没办法也就只能升级为重量级锁了。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://www.cnblogs.com/zhengbin/p/6490953.html" target="_blank" rel="noopener">VM——深入分析对象的内存布局</a><br><a href="http://blog.csdn.net/javazejian/article/details/72828483" target="_blank" rel="noopener">深入理解 Java 并发之 synchronized 实现原理</a></p><div></div></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://hackettyu.com/180927_1/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="HackettYu"><meta itemprop="description" content=""><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="HackettYu's blog"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> <a class="post-title-link" href="/180927_1/" itemprop="url">代码行统计</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-27T12:00:00+08:00">2018-09-27</time></span> <span class="post-category"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/log/" itemprop="url" rel="index"><span itemprop="name">log</span></a></span></span> <span id="/180927_1/" class="leancloud_visitors" data-flag-title="代码行统计"><span class="post-meta-divider">|</span><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span> <span class="post-meta-item-text">阅读次数&#58;</span><span class="leancloud-visitors-count"></span></span></div></header><div class="post-body" itemprop="articleBody"><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ cloc cloc/</span><br><span class="line">     465 text files.</span><br><span class="line">     427 unique files.</span><br><span class="line">     251 files ignored.</span><br><span class="line"></span><br><span class="line">http://cloc.sourceforge.net v 1.64  T=1.72 s (240.3 files/s, 16069.0 lines/s)</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">Language                     files          blank        comment           code</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">Java                           234           2277           1889          10399</span><br><span class="line">Javascript                       9            122            175           2756</span><br><span class="line">JSP                             33            176             65           2313</span><br><span class="line">HTML                            18            164             24           2001</span><br><span class="line">Python                          57            441            712           1468</span><br><span class="line">C++                             12             14             15            984</span><br><span class="line">XML                             39            109             75            801</span><br><span class="line">Bourne Shell                     2             42             44            258</span><br><span class="line">DOS Batch                        4             51              4            134</span><br><span class="line">CSS                              2             20             31             59</span><br><span class="line">JSON                             2              0              0             22</span><br><span class="line">Groovy                           2              7             15             20</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">SUM:                           414           3423           3049          21215</span><br><span class="line">-------------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><div></div></div><footer class="post-footer"><div class="post-eof"></div></footer></div></article></section><nav class="pagination"><a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left"></i></a> <a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right"></i></a></nav></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><section class="site-overview-wrap sidebar-panel sidebar-panel-active"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">HackettYu</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">34</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/index.html"><span class="site-state-item-count">4</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/index.html"><span class="site-state-item-count">23</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/HackettYu" target="_blank" title="GitHub"><i class="fa fa-fw fa-globe"></i> GitHub</a></span><span class="links-of-author-item"><a href="https://twitter.com/HackettYu" target="_blank" title="Twitter"><i class="fa fa-fw fa-globe"></i> Twitter</a></span><span class="links-of-author-item"><a href="https://www.weibo.com/u/6095046581?is_hot=1" target="_blank" title="Weibo"><i class="fa fa-fw fa-globe"></i> Weibo</a></span><span class="links-of-author-item"><a href="mailto:hy.lobby@gmail.com" target="_blank" title="Email"><i class="fa fa-fw fa-globe"></i> Email</a></span></div></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2018</span><span class="with-love"><i class="fa fa-user"></i></span> <span class="author" itemprop="copyrightHolder">HackettYu</span></div><div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div> <span class="post-meta-divider">|</span><div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script><link rel="stylesheet" href="https://aimingoo.github.io/gitmint/style/default.css"><script src="https://aimingoo.github.io/gitmint/dist/gitmint.browser.js"></script><script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script><script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script><script>AV.initialize("WFgxEYxJbyg3lmm9VCYnsDME-gzGzoHsz","du2Ur20fyRv2eIrze7uK8pID")</script><script>function showTime(e){var t=new AV.Query(e),c=[],u=$(".leancloud_visitors");u.each(function(){c.push($(this).attr("id").trim())}),t.containedIn("url",c),t.find().done(function(e){var t=".leancloud-visitors-count";if(0!==e.length){for(var n=0;n<e.length;n++){var o=e[n],i=o.get("url"),s=o.get("time"),r=document.getElementById(i);$(r).find(t).text(s)}for(n=0;n<c.length;n++){i=c[n],r=document.getElementById(i);var l=$(r).find(t);""==l.text()&&l.text(0)}}else u.find(t).text(0)}).fail(function(e,t){console.log("Error: "+t.code+" "+t.message)})}function addCount(i){var e=$(".leancloud_visitors"),s=e.attr("id").trim(),r=e.attr("data-flag-title").trim(),t=new AV.Query(i);t.equalTo("url",s),t.find({success:function(e){if(0<e.length){var t=e[0];t.fetchWhenSave(!0),t.increment("time"),t.save(null,{success:function(e){$(document.getElementById(s)).find(".leancloud-visitors-count").text(e.get("time"))},error:function(e,t){console.log("Failed to save Visitor num, with error message: "+t.message)}})}else{var n=new i,o=new AV.ACL;o.setPublicReadAccess(!0),o.setPublicWriteAccess(!0),n.setACL(o),n.set("title",r),n.set("url",s),n.set("time",1),n.save(null,{success:function(e){$(document.getElementById(s)).find(".leancloud-visitors-count").text(e.get("time"))},error:function(e,t){console.log("Failed to create")}})}},error:function(e){console.log("Error:"+e.code+" "+e.message)}})}$(function(){var e=AV.Object.extend("Counter");1==$(".leancloud_visitors").length?addCount(e):1<$(".post-title-link").length&&showTime(e)})</script><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script></body></html>